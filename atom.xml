<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>浩瀚宇宙 灿烂星空</title>
  
  <subtitle>工作和生活中的七七八八</subtitle>
  <link href="http://shaoguangleo.github.io/atom.xml" rel="self"/>
  
  <link href="http://shaoguangleo.github.io/"/>
  <updated>2025-06-19T13:19:18.875Z</updated>
  <id>http://shaoguangleo.github.io/</id>
  
  <author>
    <name>郭大侠</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="http://shaoguangleo.github.io/2025/06/19/linux-dir-beginner/"/>
    <id>http://shaoguangleo.github.io/2025/06/19/linux-dir-beginner/</id>
    <published>2025-06-19T13:19:18.875Z</published>
    <updated>2025-06-19T13:19:18.875Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>我们编程吧 集锦</title>
    <link href="http://shaoguangleo.github.io/2025/06/19/00-summary-all/"/>
    <id>http://shaoguangleo.github.io/2025/06/19/00-summary-all/</id>
    <published>2025-06-19T13:11:00.000Z</published>
    <updated>2025-06-19T13:19:18.699Z</updated>
    
    <content type="html"><![CDATA[<h1 id="我们编程吧-集锦"><a href="#我们编程吧-集锦" class="headerlink" title="我们编程吧 集锦"></a>我们编程吧 集锦</h1><h2 id="BOOK"><a href="#BOOK" class="headerlink" title="BOOK"></a>BOOK</h2><p>目前共分享了<font color="red">** 59 **</font> 个技巧，详细参考:<a href="http://shaoguangleo.github.io/2013/02/02/00-book-all"> BOOK 集锦</a></p><h2 id="C"><a href="#C" class="headerlink" title="C"></a>C</h2><p>目前共分享了<font color="red">** 128 **</font> 个技巧，详细参考:<a href="http://shaoguangleo.github.io/2013/02/02/00-c-all"> C 集锦</a></p><h2 id="CPP"><a href="#CPP" class="headerlink" title="CPP"></a>CPP</h2><p>目前共分享了<font color="red">** 16 **</font> 个技巧，详细参考:<a href="http://shaoguangleo.github.io/2013/02/02/00-cpp-all"> CPP 集锦</a></p><h2 id="GIT"><a href="#GIT" class="headerlink" title="GIT"></a>GIT</h2><p>目前共分享了<font color="red">** 115 **</font> 个技巧，详细参考:<a href="http://shaoguangleo.github.io/2013/02/02/00-git-all"> GIT 集锦</a></p><h2 id="LINUX"><a href="#LINUX" class="headerlink" title="LINUX"></a>LINUX</h2><p>目前共分享了<font color="red">** 528 **</font> 个技巧，详细参考:<a href="http://shaoguangleo.github.io/2013/02/02/00-linux-all"> LINUX 集锦</a></p><h2 id="MAC"><a href="#MAC" class="headerlink" title="MAC"></a>MAC</h2><p>目前共分享了<font color="red">** 6 **</font> 个技巧，详细参考:<a href="http://shaoguangleo.github.io/2013/02/02/00-mac-all"> MAC 集锦</a></p><h2 id="PGPLOT"><a href="#PGPLOT" class="headerlink" title="PGPLOT"></a>PGPLOT</h2><p>目前共分享了<font color="red">** 86 **</font> 个技巧，详细参考:<a href="http://shaoguangleo.github.io/2013/02/02/00-pgplot-all"> PGPLOT 集锦</a></p><h2 id="PYTHON"><a href="#PYTHON" class="headerlink" title="PYTHON"></a>PYTHON</h2><p>目前共分享了<font color="red">** 114 **</font> 个技巧，详细参考:<a href="http://shaoguangleo.github.io/2013/02/02/00-python-all"> PYTHON 集锦</a></p><h2 id="MATPLOTLIB"><a href="#MATPLOTLIB" class="headerlink" title="MATPLOTLIB"></a>MATPLOTLIB</h2><p>目前共分享了<font color="red">** 12 **</font> 个技巧，详细参考:<a href="http://shaoguangleo.github.io/2013/02/02/00-matplotlib-all"> MATPLOTLIB 集锦</a></p><h2 id="QT"><a href="#QT" class="headerlink" title="QT"></a>QT</h2><p>目前共分享了<font color="red">** 34 **</font> 个技巧，详细参考:<a href="http://shaoguangleo.github.io/2013/02/02/00-qt-all"> QT 集锦</a></p><h2 id="VIM"><a href="#VIM" class="headerlink" title="VIM"></a>VIM</h2><p>目前共分享了<font color="red">** 50 **</font> 个技巧，详细参考:<a href="http://shaoguangleo.github.io/2013/02/02/00-vim-all"> VIM 集锦</a></p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>目前共分享了<font color="red">** 1571 <strong></strong></font> 个技巧，平均每天 <font color="blue"> 0.24 **</font>个。持续更新中，欢迎来访。</p><p><img src="/2025/06/19/00-summary-all/rst.png" alt="Summary Plot"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;我们编程吧-集锦&quot;&gt;&lt;a href=&quot;#我们编程吧-集锦&quot; class=&quot;headerlink&quot; title=&quot;我们编程吧 集锦&quot;&gt;&lt;/a&gt;我们编程吧 集锦&lt;/h1&gt;&lt;h2 id=&quot;BOOK&quot;&gt;&lt;a href=&quot;#BOOK&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    <category term="集锦" scheme="http://shaoguangleo.github.io/categories/%E9%9B%86%E9%94%A6/"/>
    
    
    <category term="集锦" scheme="http://shaoguangleo.github.io/tags/%E9%9B%86%E9%94%A6/"/>
    
  </entry>
  
  <entry>
    <title>Distribution models of antennas in radio astronomy Efficiency comparison of the golden spiral interferometry</title>
    <link href="http://shaoguangleo.github.io/2024/12/24/paper-Distribution%20models%20of%20antennas%20in%20radio%20astronomy%20Efficiency%20comparison%20of%20the%20golden%20spiral%20interferometry/"/>
    <id>http://shaoguangleo.github.io/2024/12/24/paper-Distribution%20models%20of%20antennas%20in%20radio%20astronomy%20Efficiency%20comparison%20of%20the%20golden%20spiral%20interferometry/</id>
    <published>2024-12-24T14:28:30.000Z</published>
    <updated>2025-06-19T13:19:18.916Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Distribution-models-of-antennas-in-radio-astronomy-Efficiency-comparison-of-the-golden-spiral-interferometry"><a href="#Distribution-models-of-antennas-in-radio-astronomy-Efficiency-comparison-of-the-golden-spiral-interferometry" class="headerlink" title="Distribution models of antennas in radio astronomy: Efficiency comparison of the golden spiral interferometry"></a>Distribution models of antennas in radio astronomy: Efficiency comparison of the golden spiral interferometry</h1><blockquote><p>Elio Quiroga Rodríguez.</p></blockquote><p>射电天文学干涉测量中有不同的天线振兴。文章阐述了包括黄金螺旋、网格、随机排列以及类似于甚大阵列的“Y”形配置。</p><p>每种配置均模拟了一百个天线，并对所得的UV覆盖范围和图像质量进行了分析。</p><p>结果表明，黄金螺旋提供了更均匀的UV覆盖，没有明显的间隙，通过减少旁瓣和伪影提高了图像质量。</p><p>相比之下，网格在UV覆盖中呈现周期性结构，由于间隙和伪影可能会降低图像质量。</p><p>随机排列提供了更自然的覆盖，但在分辨率和旁瓣控制方面效率较低。</p><p>“Y”形配置在其臂上实现了高分辨率，但在某些方向上缺乏完整覆盖，这可能会对这些角度的图像质量产生负面影响。</p><p>黄金螺旋的自相似性允许有效捕获观测源中的大结构和小结构，最大限度地获取空间信息。</p><p>结论为，对于分辨率和灵敏度至关重要的应用，黄金螺旋是最佳配置，其次是“Y”形配置，网格是最不合适的。</p><p> 黄金螺旋在几个关键方面已被证明是优越的，包括UV覆盖、图像质量和捕获空间信息的效率。其分布最大限度地减少了基线长度的冗余，并在观测空间尺度之间提供了平滑过渡，使其对大结构和小结构都有利。相比之下，“Y”形配置因其在臂上提供高分辨率的能力而脱颖而出，但其在垂直于臂的方向上缺乏覆盖限制了其在某些情况下的应用。另一方面，随机排列比网格提供更均匀的覆盖，但在旁瓣控制方面没有达到相同水平，并且在分辨率方面可能效率较低。最后，网格是最不理想的配置，因为其周期性结构存在固有问题，导致所得图像中存在明显的间隙和伪影。</p><p>具体的描述如下：</p><h2 id="黄金螺旋构型"><a href="#黄金螺旋构型" class="headerlink" title="黄金螺旋构型"></a>黄金螺旋构型</h2><p>UV覆盖特性：黄金螺旋构型提供了更为均匀的UV覆盖，不存在显著间隙。这一特性归因于其对数性质，使得在UV平面上的采样点分布更加合理，能够有效减少因覆盖不均匀而产生的成像问题。例如，在模拟图像中可以观察到其成像特性更为平滑，相较于其他构型，对观测源的空间信息采集更为全面且均衡。</p><p><strong>对成像质量的影响</strong>：通过减少旁瓣和伪影，黄金螺旋构型显著提升了成像质量。均匀的UV覆盖确保了在傅里叶变换过程中，不同空间频率成分能够得到更准确的采样和恢复，从而在最终图像中呈现出更清晰、更真实的天体结构。在与其他构型对比的模拟图像中，该构型所生成的图像在细节呈现和整体清晰度上表现出色，伪影和旁瓣干扰明显减少。 </p><p> <strong>空间尺度敏感性</strong>：其自相似性使得望远镜能够在多个尺度上保持良好的覆盖，对观测对象中的大尺度和小尺度结构均具有较高的敏感性。这意味着无论是大规模的星系结构还是小范围的恒星形成区域，黄金螺旋构型都能够有效地捕捉到相关信息，从而提供更为丰富的天体物理细节。在对不同类型天体的观测模拟中，该构型能够更全面地展现天体的多尺度特征，从宏观结构到微观细节都能清晰分辨。 </p><h2 id="网格构型"><a href="#网格构型" class="headerlink" title="网格构型"></a>网格构型</h2><p> <strong>UV覆盖周期性结构</strong>：正方形网格构型在UV覆盖中呈现出明显的周期性结构。这种周期性导致在图像中容易出现旁瓣，周期性的间隙还会引入显著的伪影，从而严重影响成像质量。例如，在UV覆盖图中可以清晰看到规则的网格图案，这使得在图像重建过程中，某些空间频率成分被过度强调或缺失，进而产生伪影和旁瓣效应。 </p><p> <strong>对成像的负面影响</strong>：由于上述周期性结构带来的问题，网格构型生成的图像整体质量下降。旁瓣会掩盖天体的真实信号，使图像中的微弱结构难以被检测到；伪影则会误导对天体形态和结构的判断。在对天体细节要求较高的观测中，网格构型的这种局限性表现得尤为明显，导致其在四种构型中成像效果最差。 </p><h2 id="随机构型"><a href="#随机构型" class="headerlink" title="随机构型"></a>随机构型</h2><p> <strong>覆盖特性</strong>：随机排列构型提供了相对自然的覆盖，但这种随机性也带来了一些问题。虽然它在一定程度上避免了像网格构型那样的周期性结构，但由于缺乏系统性，其覆盖的均匀性仍不如黄金螺旋构型。在UV覆盖图中，随机构型的采样点分布较为分散，没有明显的规律，这可能导致在某些区域的覆盖不足或过度，从而影响成像效果。 </p><p> <strong>分辨率和旁瓣控制效率</strong>：随机构型在分辨率和旁瓣控制方面的效率较低。由于天线位置的随机性，其形成的基线组合不够优化，使得在傅里叶变换过程中对空间频率的采样不够精确，进而影响了图像的分辨率。同时，随机的基线分布也难以有效抑制旁瓣的产生，导致图像中旁瓣较多，降低了图像的对比度和清晰度，与布恩的观点存在一定矛盾。 </p><h2 id="“Y”形构型"><a href="#“Y”形构型" class="headerlink" title="“Y”形构型"></a>“Y”形构型</h2><p> <strong>臂上的高分辨率</strong>：“Y”形构型在其臂上能够实现高分辨率成像，这得益于其长基线的设计。长基线使得在臂方向上对空间频率的采样更为精细，能够捕捉到更细微的结构信息。在对具有明显线性结构的天体（如星系旋臂、射电喷流等）进行观测时，“Y”形构型在臂上的高分辨率优势得以充分体现，能够清晰地呈现出这些结构的细节。</p><p> <strong>覆盖稀疏问题</strong>：然而，“Y”形构型在垂直于臂的方向上覆盖较为稀疏。这种稀疏性可能导致在这些方向上的空间信息采集不足，从而在图像中产生覆盖不完整的区域，容易出现潜在的成像伪影。在对整体结构较为复杂、不具有明显线性特征的天体进行观测时，“Y”形构型在某些角度的成像质量可能会受到影响，限制了其在更广泛观测场景中的应用。 通过对不同构型在UV覆盖、成像质量、分辨率以及空间尺度敏感性等方面的详细描述和对比，可以清晰地呈现出各种构型的优缺点，为后续关于阵列配置优化及其对干涉成像影响的讨论提供有力依据。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Distribution-models-of-antennas-in-radio-astronomy-Efficiency-comparison-of-the-golden-spiral-interferometry&quot;&gt;&lt;a href=&quot;#Distribution</summary>
      
    
    
    
    <category term="READING" scheme="http://shaoguangleo.github.io/categories/READING/"/>
    
    
    <category term="imaging" scheme="http://shaoguangleo.github.io/tags/imaging/"/>
    
    <category term="UV coverage" scheme="http://shaoguangleo.github.io/tags/UV-coverage/"/>
    
    <category term="UV覆盖" scheme="http://shaoguangleo.github.io/tags/UV%E8%A6%86%E7%9B%96/"/>
    
    <category term="Synthetic" scheme="http://shaoguangleo.github.io/tags/Synthetic/"/>
    
    <category term="spiral" scheme="http://shaoguangleo.github.io/tags/spiral/"/>
    
  </entry>
  
  <entry>
    <title>SMILI 安装说明</title>
    <link href="http://shaoguangleo.github.io/2024/04/09/radio_astronomy_install_smili/"/>
    <id>http://shaoguangleo.github.io/2024/04/09/radio_astronomy_install_smili/</id>
    <published>2024-04-09T13:11:00.000Z</published>
    <updated>2025-06-19T13:19:18.940Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SMILI-安装说明"><a href="#SMILI-安装说明" class="headerlink" title="SMILI 安装说明"></a>SMILI 安装说明</h1><p>安装依赖</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">sudo</span> apt install x11*</span><br><span class="line">$ <span class="built_in">sudo</span> apt install libxt-dev</span><br><span class="line">$ <span class="built_in">sudo</span> apt install libopenblas-dev</span><br></pre></td></tr></tbody></table></figure><h2 id="安装-OpenBLAS"><a href="#安装-OpenBLAS" class="headerlink" title="安装 OpenBLAS"></a>安装 OpenBLAS</h2><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Clone the current repository</span></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/xianyi/OpenBLAS</span><br><span class="line"></span><br><span class="line"><span class="comment"># Compile and install</span></span><br><span class="line"><span class="comment">#   macOS MacPorts users may not use USE_OPENMP=1 option, and need to omit it.</span></span><br><span class="line"><span class="built_in">cd</span> OpenBLAS</span><br><span class="line">make USE_OPENMP=1 CC=gcc FC=gfortran</span><br><span class="line">make PREFIX=<span class="string">"~/local"</span> install</span><br><span class="line"></span><br><span class="line"><span class="comment"># 确认是否安装正确</span></span><br><span class="line"><span class="comment"># 是否有输出</span></span><br><span class="line">$ pkg-config --debug openblas</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果没有，增加pkg的path</span></span><br><span class="line"><span class="built_in">export</span> PKG_CONFIG_PATH=~/local/lib/pkgconfig:<span class="variable">$PKG_CONFIG_PATH</span></span><br></pre></td></tr></tbody></table></figure><h2 id="安装FFTW3"><a href="#安装FFTW3" class="headerlink" title="安装FFTW3"></a>安装FFTW3</h2><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ apt install fftw*</span><br><span class="line"></span><br><span class="line"><span class="comment"># 确认是否安装正确</span></span><br><span class="line"><span class="comment"># 是否有输出</span></span><br><span class="line">$ pkg-config --debug fftw3</span><br></pre></td></tr></tbody></table></figure><h2 id="安装-FINUFFT"><a href="#安装-FINUFFT" class="headerlink" title="安装 FINUFFT"></a>安装 FINUFFT</h2><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下载源码</span></span><br><span class="line">$ <span class="built_in">cd</span> ~/local</span><br><span class="line">$ git <span class="built_in">clone</span> https://github.com/flatironinstitute/finufft</span><br><span class="line">$ <span class="built_in">cd</span> finufft</span><br></pre></td></tr></tbody></table></figure><p>准备make.inc文件，内容如下：</p><figure class="highlight makefile"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Compilers</span></span><br><span class="line">CXX=g++</span><br><span class="line">CC=gcc</span><br><span class="line">FC=gfortran</span><br><span class="line"></span><br><span class="line"><span class="comment"># (compile flags for use with GCC are as in linux makefile)</span></span><br><span class="line">CFLAGS +=</span><br><span class="line"></span><br><span class="line"><span class="comment"># If you're getting warning messages of the form:</span></span><br><span class="line"><span class="comment">#    ld: warning: object file (lib-static/libfinufft.a(finufft1d.o)) was built for</span></span><br><span class="line"><span class="comment">#    newer OSX version (10.13) than being linked (10.9)</span></span><br><span class="line"><span class="comment"># Then you can uncomment the following two lines with the older version number</span></span><br><span class="line"><span class="comment"># (in this example -mmacosx-version-min=10.9)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#CFLAGS += "-mmacosx-version-min=&lt;OLDER OSX VERSION NUMBER&gt;"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># if you are macOS homebrew users, uncomment this.</span></span><br><span class="line"><span class="comment"># (assuming that /usr/local is your homebrew's PREFIX)</span></span><br><span class="line"><span class="comment">#CFLAGS += -I src -I/usr/local/include</span></span><br><span class="line"><span class="comment">#LIBS += -L/usr/local/lib</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># if you are macOS MacPorts users, uncomment this.</span></span><br><span class="line"><span class="comment"># (assuming that /opt/local is your MacPorts' PREFIX)</span></span><br><span class="line"><span class="comment">#CFLAGS += -I src -I/opt/local/include</span></span><br><span class="line"><span class="comment">#LIBS += -L/opt/local/lib</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Your FFTW3's installation PREFIX</span></span><br><span class="line">CFLAGS += -I$HOME/local/<span class="keyword">include</span></span><br><span class="line">LIBS += -L$HOME/local/lib</span><br><span class="line"></span><br><span class="line"><span class="comment"># You can keep them</span></span><br><span class="line">FFLAGS   = <span class="variable">$(CFLAGS)</span></span><br><span class="line">CXXFLAGS = <span class="variable">$(CFLAGS)</span> -DNEED_EXTERN_C</span><br><span class="line"></span><br><span class="line"><span class="comment"># OpenMP with GCC on OSX needs following...</span></span><br><span class="line">OMPFLAGS = -fopenmp</span><br><span class="line">OMPLIBS = -lgomp</span><br><span class="line"><span class="comment"># since fftw3_omp doesn't work in OSX, you need to uncomment this</span></span><br><span class="line"><span class="comment">#FFTWOMPSUFFIX=threads</span></span><br></pre></td></tr></tbody></table></figure><p>开始编译库</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ make lib</span><br></pre></td></tr></tbody></table></figure><p>新建finufft.pc文件，内容如下：</p><figure class="highlight makefile"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># This is an example pkg-config file. Here is an brief instruction.</span></span><br><span class="line"><span class="comment"># (1) Please change finufftdir depending on your install directory.</span></span><br><span class="line"><span class="comment"># (2) please change its filename to finufft.sample.pc and</span></span><br><span class="line"><span class="comment">#     copy to a directory specified in $PKG_CONFIG_PATH</span></span><br><span class="line">finufftdir=<span class="variable">$(HOME)</span>/local/finufft</span><br><span class="line">libdir=${finufftdir}/lib-static</span><br><span class="line">includedir=${finufftdir}/<span class="keyword">include</span></span><br><span class="line"></span><br><span class="line"><span class="section">Name: FINUFFT</span></span><br><span class="line"><span class="section">Description: Flatiron Institute Nonuniform Fast Fourier Transform libraries</span></span><br><span class="line"><span class="section">Version: github</span></span><br><span class="line"><span class="section">Libs: -L${libdir} -lfinufft</span></span><br><span class="line"><span class="section">Cflags: -I${includedir}</span></span><br></pre></td></tr></tbody></table></figure><p>确认是否安装完毕</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 确认是否安装正确</span></span><br><span class="line"><span class="comment"># 是否有输出</span></span><br><span class="line">$ pkg-config --debug finufft</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果没有，增加pkg的path</span></span><br><span class="line"><span class="built_in">export</span> PKG_CONFIG_PATH=~/local/finufft/:<span class="variable">$PKG_CONFIG_PATH</span></span><br></pre></td></tr></tbody></table></figure><h2 id="安装SMILI"><a href="#安装SMILI" class="headerlink" title="安装SMILI"></a>安装SMILI</h2><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Clone the repository</span></span><br><span class="line">$ git <span class="built_in">clone</span> https://github.com/astrosmili/smili</span><br><span class="line">$ <span class="built_in">cd</span> smili</span><br><span class="line"><span class="comment"># 通过conda创建虚拟环境，不然编译会有问题</span></span><br><span class="line">$ ./configure</span><br><span class="line">$ make install</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;SMILI-安装说明&quot;&gt;&lt;a href=&quot;#SMILI-安装说明&quot; class=&quot;headerlink&quot; title=&quot;SMILI 安装说明&quot;&gt;&lt;/a&gt;SMILI 安装说明&lt;/h1&gt;&lt;p&gt;安装依赖&lt;/p&gt;
&lt;figure class=&quot;highlight bash</summary>
      
    
    
    
    <category term="射电天文" scheme="http://shaoguangleo.github.io/categories/%E5%B0%84%E7%94%B5%E5%A4%A9%E6%96%87/"/>
    
    
    <category term="astronomy" scheme="http://shaoguangleo.github.io/tags/astronomy/"/>
    
    <category term="天文" scheme="http://shaoguangleo.github.io/tags/%E5%A4%A9%E6%96%87/"/>
    
    <category term="射电" scheme="http://shaoguangleo.github.io/tags/%E5%B0%84%E7%94%B5/"/>
    
    <category term="radio" scheme="http://shaoguangleo.github.io/tags/radio/"/>
    
    <category term="radio astronomy" scheme="http://shaoguangleo.github.io/tags/radio-astronomy/"/>
    
    <category term="smili" scheme="http://shaoguangleo.github.io/tags/smili/"/>
    
  </entry>
  
  <entry>
    <title>信佛姓佛</title>
    <link href="http://shaoguangleo.github.io/2024/02/24/diary-20240224-%E4%BF%A1%E4%BD%9B%E5%A7%93%E4%BD%9B/"/>
    <id>http://shaoguangleo.github.io/2024/02/24/diary-20240224-%E4%BF%A1%E4%BD%9B%E5%A7%93%E4%BD%9B/</id>
    <published>2024-02-24T14:03:00.000Z</published>
    <updated>2025-06-19T13:19:18.710Z</updated>
    
    <content type="html"><![CDATA[<h1 id="信佛姓佛"><a href="#信佛姓佛" class="headerlink" title="信佛姓佛"></a>信佛姓佛</h1><p>妈妈：妈妈的外婆信佛，一辈子不吃肉</p><p>天文：妈妈，幸亏我们姓郭，不姓佛，不然就不能吃肉了</p><p>爸爸：一脸黑线</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;信佛姓佛&quot;&gt;&lt;a href=&quot;#信佛姓佛&quot; class=&quot;headerlink&quot; title=&quot;信佛姓佛&quot;&gt;&lt;/a&gt;信佛姓佛&lt;/h1&gt;&lt;p&gt;妈妈：妈妈的外婆信佛，一辈子不吃肉&lt;/p&gt;
&lt;p&gt;天文：妈妈，幸亏我们姓郭，不姓佛，不然就不能吃肉了&lt;/p&gt;
&lt;p&gt;爸爸：一</summary>
      
    
    
    
    <category term="日记" scheme="http://shaoguangleo.github.io/categories/%E6%97%A5%E8%AE%B0/"/>
    
    
    <category term="天文" scheme="http://shaoguangleo.github.io/tags/%E5%A4%A9%E6%96%87/"/>
    
    <category term="生活" scheme="http://shaoguangleo.github.io/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>溪水里的小鱼</title>
    <link href="http://shaoguangleo.github.io/2024/01/05/diary-20240105-fish-in-the-water/"/>
    <id>http://shaoguangleo.github.io/2024/01/05/diary-20240105-fish-in-the-water/</id>
    <published>2024-01-05T14:28:00.000Z</published>
    <updated>2025-06-19T13:19:18.710Z</updated>
    
    <content type="html"><![CDATA[<h1 id="溪水里的小鱼"><a href="#溪水里的小鱼" class="headerlink" title="溪水里的小鱼"></a>溪水里的小鱼</h1><p>在所有卵中，我觉得最有意思的是鱼卵。</p><p>几乎所有鱼卵都是非常小的白色圆球，就像糖丸一样。</p><p>有些鱼卵像中等大小的玻璃珠，比如在急流中砾石滩上常见的鳟鱼或鲑鱼卵；还有许多小得能穿过织补针的针眼，比如贴着海面漂浮的海鱼卵。</p><p>不管怎样，特别令人感兴趣的是，那么多鱼卵像极了小玻璃球。</p><p>其外层薄膜非常清透，卵本身也非常透明，你完全可以用放大镜透视鱼卵，目睹里面的白色斑点从无到有，发育成真正的鱼。</p><p>它卧在卵里，身长足以环绕卵一周，尾巴几乎和嘴相连。</p><p>有些鱼卵更加清透。最清透的卵起初好似透明玻璃，在水下完全不见踪影。</p><p>不久以后，其底部开始形成模糊的小白点。</p><p>接着，你能看见卵上覆盖着相当厚的膜，膜中有一个狭窄而清澈的空间，充满了水，里面漂浮着更小的卵黄。</p><p>这个时候它才是即将变成小鱼的真正的卵。</p><p>卵黄中的白色斑点本身并不是鱼，而是鱼物质，是为逐渐发育成鱼而做的准备。</p><p>斑点越长越大，越长越厚，最终，看上去好似涂在大理石边的一圈腻子。</p><p>卵膜直径接近卵本身的一半时，中间开始变薄，边缘变厚，形成一个环。</p><p>紧接着，这个环会发生非常奇特的变化。它开始长大，并在这个过程中环绕着鱼卵越滑越远，不久便形成以卵为中心的带状物，继续向外滑行，直至卵的另一侧。</p><p>当然，它会相应变得小一些。就这样，其多余部分收进环上的某一点，形成小鱼的身体。</p><p>在经过卵中心之前，环的增厚部分已经形成鱼头，环的两端形成身体的两部分。鱼尾比较容易发育，所以很久以后才会长出来。<br>现在，小鱼有头和身子了，唯一不同的是头比较大。</p><p>它还没有任何器官，没有眼睛、耳朵、鼻子，或完整的嘴，也没有鳍、脊椎、胃，以及鳞片。</p><p>这些都会在以后出现，就像小鸡的发育一样——眼睛、耳朵、大脑和心脏先发育，鳍、尾巴和鳞片，以及整个身体前部需要很久以后才发育成形。</p><p>许多科学家倾尽毕生精力，研究小动物各种肢体器官形成的方式。</p><p>这是一项最奇特，也最令人着迷的课题，值得任何人耗费一生进行研究。</p><p>但是，如果要我讲述鱼体最小部位形成的全部过程，本书就没有地方讲述其他故事了。</p><p>所以，我只想讲讲眼睛，部分因为它们是有趣而重要的器官，更多的是因为它们形成的方式碰巧和所有脊椎动物眼睛形成的方式相同——无论鱼类，蛙类、鸟类、四足野兽，还是人类。</p><p>亲爱的读者，你看这本书的眼睛也是如同我亲眼所见的鳕鱼和海鲈鱼的眼睛那样发育而成。</p><p>一般来说，最早形成的身体部位是大脑，紧接着是眼睛。</p><p>刚萌生的眼睛像两个蓓蕾，从即将成为头部的大脑两侧冒芽。此时，每只眼睛都是空的，好似挂在短柄上的气泡，很像铅笔头上粘着的空心橡皮球，只是大小不同。</p><p>你会以为，这个空心球会直接变成眼球。</p><p>可是，你错了，大自然很少简单行事。相反，像你用手指推动橡皮球一样，眼芽的一侧会向内折，直到形成杯状。</p><p>这个杯就是眼球。它的边缘长出来，杯口渐渐收缩至我们称之为瞳孔的眼睛中央。</p><p>各种各样的眼部物质在其边缘生长，构成眼睛的内部组织。其他组织在外部生长，加厚外壁，形成前面透明的角膜。</p><p>此时，瞳孔依然很大，以后会成为表皮的部分物质向眼球内生长，形成眼睛的晶状体。眼芽最初内折形成杯状，随后收缩成为我们最终使用的眼球，这种反向发育的目的是为了将各种物质纳入眼睛，最终留下瞳孔透入光明。</p><p>到目前为止，像小鸡一样，小鱼的身体前部还没有发育成形。</p><p>小鱼卧在卵黄里，好似肚子疼的孩子，抱着枕头，缩成一团。</p><p>渐渐地，尾巴从卵黄中长出来，鱼头也完全抬起来，给下颚留出发育的空间。</p><p>最后，身体各部在卵黄周围发育完成，并安置在最恰当的部位。<br>这时，鱼已经做好孵化准备。它时不时地在卵膜中扭动一会儿，最后突破卵膜，漂浮出来。这是一个弱小无助的生命，只比半个卵黄大一点。它不会游泳，只是肚皮朝上漂浮着，嘴巴大张，还没能合拢下巴。<br>从这时起，小鱼以越来越小的卵黄为食，迅速成长。</p><p>起初，这个小生命依靠背部浮动，时而摆动一下。随着卵黄变得易于掌控，小鱼越来越频繁地摆动起来。</p><p>不久，它翻为侧身，然后完全侧过身来。等到卵黄全部消失，它就侧身游动起来，并且开始进食更小的水生物。</p><p>在这个阶段，如果是淡水鱼，你会在浅滩处看见它们成群地游动。</p><p>不过，这些鱼长只有6毫米左右，而且多半是眼睛。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;溪水里的小鱼&quot;&gt;&lt;a href=&quot;#溪水里的小鱼&quot; class=&quot;headerlink&quot; title=&quot;溪水里的小鱼&quot;&gt;&lt;/a&gt;溪水里的小鱼&lt;/h1&gt;&lt;p&gt;在所有卵中，我觉得最有意思的是鱼卵。&lt;/p&gt;
&lt;p&gt;几乎所有鱼卵都是非常小的白色圆球，就像糖丸一样。&lt;/p&gt;</summary>
      
    
    
    
    <category term="日记" scheme="http://shaoguangleo.github.io/categories/%E6%97%A5%E8%AE%B0/"/>
    
    
    <category term="life" scheme="http://shaoguangleo.github.io/tags/life/"/>
    
    <category term="童言无忌" scheme="http://shaoguangleo.github.io/tags/%E7%AB%A5%E8%A8%80%E6%97%A0%E5%BF%8C/"/>
    
    <category term="儿童必读的自然奇迹" scheme="http://shaoguangleo.github.io/tags/%E5%84%BF%E7%AB%A5%E5%BF%85%E8%AF%BB%E7%9A%84%E8%87%AA%E7%84%B6%E5%A5%87%E8%BF%B9/"/>
    
    <category term="天天文文" scheme="http://shaoguangleo.github.io/tags/%E5%A4%A9%E5%A4%A9%E6%96%87%E6%96%87/"/>
    
  </entry>
  
  <entry>
    <title>linux中最常用的网络命令</title>
    <link href="http://shaoguangleo.github.io/2024/01/02/linux-collection-network-commands/"/>
    <id>http://shaoguangleo.github.io/2024/01/02/linux-collection-network-commands/</id>
    <published>2024-01-02T14:28:00.000Z</published>
    <updated>2025-06-19T13:19:18.872Z</updated>
    
    <content type="html"><![CDATA[<h1 id="linux中最常用的网络命令"><a href="#linux中最常用的网络命令" class="headerlink" title="linux中最常用的网络命令"></a>linux中最常用的网络命令</h1><blockquote><p> 仅个人想法，会持续不间断更新和改进。</p></blockquote><p>虚虚假假，真真实实，如何快速的去伪存真，抽丝剥茧。</p><p>需要在开放的网络世界掌握一些最基础的命令，让自己知己知彼。</p><hr><h2 id="查看网络信息的原初-ifconfig"><a href="#查看网络信息的原初-ifconfig" class="headerlink" title="查看网络信息的原初 ifconfig"></a>查看网络信息的原初 ifconfig</h2><p>Linux <code>ifconfig</code>命令用于显示或设置网络设备，在调试或调优的时间经常使用。</p><p>官方定义为：</p><blockquote><p>ifconfig - configure a network interface</p></blockquote><p>对于这个命令，一般只要掌握如何查看，如何设置IP地址基本就可以了，对于网络钻的比较深的，还需要更多一些参数。</p><p>使用方法为：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 显示</span></span><br><span class="line">$ ifconfig [-v] [-a] [-s] [interface]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置</span></span><br><span class="line">$ ifconfig [-v] interface [aftype] options | address ...</span><br></pre></td></tr></tbody></table></figure><p>一些参数的含义为：</p><ul><li><code>-a</code> ：显示所有网卡的状态，即使是down的状态</li><li><code>-s</code>：显示一个短列表</li><li><code>interface mtu N</code>  设置最大传输单元【需要管理员权限】</li><li><code>netmask addr</code>：设置掩码地址【需要管理员权限】</li><li><code>interface up</code>     激活网卡【需要管理员权限】</li><li><code>interface down</code>   关闭网卡【需要管理员权限】</li><li><code>interface hw ether xx.xx.xx.xx.xx.xx</code> 设置MAC地址【需要管理员权限】</li></ul><h3 id="默认无参数使用"><a href="#默认无参数使用" class="headerlink" title="默认无参数使用"></a>默认无参数使用</h3><p>如果不指定任何参数，直接显示当前<strong>活动</strong>的接口，如下：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">$ ifconfig</span><br><span class="line">eth0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span><br><span class="line">        inet 192.168.1.123  netmask 255.255.255.0  broadcast 192.168.1.255</span><br><span class="line">        inet6 xxxx::xxxx:xxxx:xxxx:xxxx  prefixlen 64  scopeid 0x20&lt;<span class="built_in">link</span>&gt;</span><br><span class="line">        inet6 xxxx:xxxx:xxxx:xxxx:xxxx:xxxx:xxxx:xxxx  prefixlen 64  scopeid 0x0&lt;global&gt;</span><br><span class="line">        ether xx:xx:xx:xx:xx:xx  txqueuelen 1000  (Ethernet)</span><br><span class="line">        RX packets 5634431  bytes 4994127142 (4.6 GiB)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 858051  bytes 109858013 (104.7 MiB)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line">        device memory 0xc7320000-c733ffff  </span><br><span class="line"></span><br><span class="line">eth1: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span><br><span class="line">        inet 192.168.6.123  netmask 255.255.255.0  broadcast 192.168.6.255</span><br><span class="line">        inet6 xxxx::xxxx:xxxx:xxxx:xxxx  prefixlen 64  scopeid 0x20&lt;<span class="built_in">link</span>&gt;</span><br><span class="line">        ether xx:xx:xx:xx:xx:xx  txqueuelen 1000  (Ethernet)</span><br><span class="line">        RX packets 1547215  bytes 92862867 (88.5 MiB)</span><br><span class="line">        RX errors 0  dropped 6  overruns 0  frame 0</span><br><span class="line">        TX packets 3230  bytes 922051 (900.4 KiB)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line"></span><br><span class="line">lo: flags=73&lt;UP,LOOPBACK,RUNNING&gt;  mtu 65536</span><br><span class="line">        inet 127.0.0.1  netmask 255.0.0.0</span><br><span class="line">        inet6 ::1  prefixlen 128  scopeid 0x10&lt;host&gt;</span><br><span class="line">        loop  txqueuelen 1000  (Local Loopback)</span><br><span class="line">        RX packets 219608  bytes 105943591 (101.0 MiB)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 219608  bytes 105943591 (101.0 MiB)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br></pre></td></tr></tbody></table></figure><p>其中一般希望看到的信息包括：</p><ul><li><strong>inet</strong>：为IP地址</li><li><strong>ether</strong>：为MAC地址</li><li><strong>MTU</strong>：最大传输单元</li></ul><p>不加任何参数只会显示已经配置并且活跃的网卡信息，如果使用<code>ifconfig -a</code>就可以显示全部的网卡状态了，即使有些网卡是down的状态。</p><p>亦或者指定一个<u>interface</u>，比如上面的<strong>eth1</strong>，则只输出这个网卡的信息，如下：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ ifconfig eth1</span><br><span class="line"></span><br><span class="line">eth1: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span><br><span class="line">        inet 192.168.6.123  netmask 255.255.255.0  broadcast 192.168.6.255</span><br><span class="line">        inet6 xxxx::xxxx:xxxx:xxxx:xxxx  prefixlen 64  scopeid 0x20&lt;<span class="built_in">link</span>&gt;</span><br><span class="line">        ether xx:xx:xx:xx:xx:xx  txqueuelen 1000  (Ethernet)</span><br><span class="line">        RX packets 1547215  bytes 92862867 (88.5 MiB)</span><br><span class="line">        RX errors 0  dropped 6  overruns 0  frame 0</span><br><span class="line">        TX packets 3230  bytes 922051 (900.4 KiB)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br></pre></td></tr></tbody></table></figure><h3 id="s显示短列表"><a href="#s显示短列表" class="headerlink" title="-s显示短列表"></a>-s显示短列表</h3><p>如果只想看到MTU以及数据包的状态，可以用该参数，如下：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ ifconfig -s</span><br><span class="line">Iface      MTU    RX-OK RX-ERR RX-DRP RX-OVR    TX-OK TX-ERR TX-DRP TX-OVR Flg</span><br><span class="line">eth0     1500   5665450      0      0 0        867639      0      0      0 BMRU</span><br><span class="line">eth1     1500   3489187217   0 101054 0      501260400     0      0      0 BMU</span><br><span class="line">lo       65536  219708       0      0 0        219708      0      0      0 LRU</span><br></pre></td></tr></tbody></table></figure><p>输出信息主要包含了MTU值，发送及接收的数据情况。</p><h3 id="配置IP地址"><a href="#配置IP地址" class="headerlink" title="配置IP地址"></a>配置IP地址</h3><p>如下对eth0网卡配置IP地址、掩码以及广播地址，当然可以分布操作</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 给eth0配置IP地址</span></span><br><span class="line">$ ifconfig eth0 192.168.1.123 </span><br><span class="line"></span><br><span class="line"><span class="comment"># 给eth0配置IP地址和子网掩码</span></span><br><span class="line">$ ifconfig eth0 192.168.1.123 netmask 255.255.255.0 </span><br><span class="line"></span><br><span class="line"><span class="comment"># 给eth0配置IP地址、子网掩码还有广播地址</span></span><br><span class="line">$ ifconfig eth0 192.168.1.123 netmask 255.255.255.0 broadcast 192.168.1.255</span><br></pre></td></tr></tbody></table></figure><h3 id="修改MTU"><a href="#修改MTU" class="headerlink" title="修改MTU"></a>修改MTU</h3><p>在某些情况下可能需要修改MTU值，比如增到到MTU为9000，如下：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">$ ifconfig eth1</span><br><span class="line">eth1: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span><br><span class="line">        inet 192.168.6.123  netmask 255.255.255.0  broadcast 192.168.6.255</span><br><span class="line">        inet6 xxxx::xxxx:xxxx:xxxx:xxxx  prefixlen 64  scopeid 0x20&lt;<span class="built_in">link</span>&gt;</span><br><span class="line">        ether xx:xx:xx:xx:xx:xx  txqueuelen 1000  (Ethernet)</span><br><span class="line">        RX packets 1547215  bytes 92862867 (88.5 MiB)</span><br><span class="line">        RX errors 0  dropped 6  overruns 0  frame 0</span><br><span class="line">        TX packets 3230  bytes 922051 (900.4 KiB)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改MTU</span></span><br><span class="line">$ ifconfig eth1 MTU 9000</span><br><span class="line"></span><br><span class="line">$ ifconfig eth1</span><br><span class="line">eth1: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 9000</span><br><span class="line">        inet 192.168.6.123  netmask 255.255.255.0  broadcast 192.168.6.255</span><br><span class="line">        inet6 xxxx::xxxx:xxxx:xxxx:xxxx  prefixlen 64  scopeid 0x20&lt;<span class="built_in">link</span>&gt;</span><br><span class="line">        ether xx:xx:xx:xx:xx:xx  txqueuelen 1000  (Ethernet)</span><br><span class="line">        RX packets 1547215  bytes 92862867 (88.5 MiB)</span><br><span class="line">        RX errors 0  dropped 6  overruns 0  frame 0</span><br><span class="line">        TX packets 3230  bytes 922051 (900.4 KiB)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br></pre></td></tr></tbody></table></figure><p>已经看到输出的信息已经把mtu更新为了9000.</p><blockquote><p>这个值对网络传输影响很大。</p></blockquote><h3 id="启动关闭网卡"><a href="#启动关闭网卡" class="headerlink" title="启动关闭网卡"></a>启动关闭网卡</h3><p>启动关闭主要的应用场景为重新设置了IP地址，或者暂时对某个网卡进行操作。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 关闭eth0</span></span><br><span class="line">$ ifconfig eth0 down</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动eth0</span></span><br><span class="line">$ ifconfig eth0 up</span><br></pre></td></tr></tbody></table></figure><p>不过需要注意的是</p><ol><li>很多的设置操作都需要管理员权限；</li><li>很多操作在重启后设置都会还原，如果需要永久设置，需要更改<u>network</u>的一些配置文件；</li><li><u>这个程序基本被淘汰了</u>，已经不在更新，所有的操作或者用法均可以通过<code>ip</code>来搞定。等明天~。</li></ol><h2 id="网络中不中，先看ping行不行"><a href="#网络中不中，先看ping行不行" class="headerlink" title="网络中不中，先看ping行不行"></a>网络中不中，先看ping行不行</h2><p>在<strong>linux</strong>系统里面如果想判断网络的好坏，脑海中蹦出的第一个命令就是<code>ping</code>了。</p><p>官方定义为：</p><blockquote><p>ping - send ICMP ECHO_REQUEST to network hosts</p></blockquote><p><code>ping</code>命令基本是最常用的网络命令，它可以用来测试与目标主机的连通性。</p><p><code>ping</code>使用ICMP传输协议，通过发送<u>ICMP ECHO_REQUEST</u>数据包到网络主机，并显示返回的相应情况，根据这些信息就可以判断目标主机是否可以访问，在发送的过程中还会有一个时间戳用来计算网络的状态。</p><p>不过有些服务器为了防止通过<code>ping</code>探测到，可能会在防火墙或者内核参数中禁止<code>ping</code>命令，这样的话，可能虽然目标主机可以访问，但是无法<code>ping</code>通，所以并不能说<code>ping</code>不通的网络就是不能访问的。</p><blockquote><p>需要注意linux下的ping和windows下的ping稍有区别,linux下ping不会自动终止,需要按ctrl+c终止或者用参数-c指定要求完成的回应次数。</p></blockquote><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p><code>ping</code>的使用说实话挺复杂，挺多的，不过常用的这篇短文基本就够了。</p><p>详细如下：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ALL</span></span><br><span class="line">$ ping  [-aAbBdDfhLnOqrRUvV46]  [-c  count]  [-F  flowlabel]  [-i  interval]  [-I interface] [-l preload] [-m mark] [-M pmtudisc_option] [-N node‐info_option] [-w deadline] [-W <span class="built_in">timeout</span>] [-p pattern] [-Q tos] [-s packetsize] [-S sndbuf] [-t ttl] [-T timestamp option] [hop ...] destination</span><br><span class="line"></span><br><span class="line"><span class="comment"># 较常用的选项如下：</span></span><br><span class="line">$ ping   [-c  count]   [-i  interval]  destination</span><br></pre></td></tr></tbody></table></figure><p><strong>参数说明</strong>：</p><ul><li><p><code>-c</code> &lt;完成次数&gt; 设置完成要求回应的次数。</p></li><li><p><code>-i interval</code> 指定收发信息的间隔时间。</p></li></ul><h3 id="不加任何参数"><a href="#不加任何参数" class="headerlink" title="不加任何参数"></a>不加任何参数</h3><p>如果不加任何参数，查看是否<code>ping</code>通</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ ping www.baidu.com   </span><br><span class="line">PING www.a.shifen.com (115.239.210.27) 56(84) bytes of data.</span><br><span class="line">64 bytes from 115.239.210.27: icmp_seq=1 ttl=52 <span class="keyword">time</span>=6.06 ms</span><br><span class="line">64 bytes from 115.239.210.27: icmp_seq=2 ttl=52 <span class="keyword">time</span>=5.56 ms</span><br><span class="line">64 bytes from 115.239.210.27: icmp_seq=3 ttl=52 <span class="keyword">time</span>=5.67 ms</span><br><span class="line">64 bytes from 115.239.210.27: icmp_seq=4 ttl=52 <span class="keyword">time</span>=5.82 ms</span><br><span class="line">64 bytes from 115.239.210.27: icmp_seq=5 ttl=52 <span class="keyword">time</span>=5.70 ms</span><br><span class="line">64 bytes from 115.239.210.27: icmp_seq=6 ttl=52 <span class="keyword">time</span>=5.79 ms  </span><br><span class="line">^C <span class="comment"># 此处输入了Ctrl+C强制退出</span></span><br><span class="line"> --- 192.168.1.123 ping statistics ---</span><br><span class="line">5 packets transmitted, 5 received, 0% packet loss, <span class="keyword">time</span> 3999ms</span><br><span class="line">rtt min/avg/max/mdev = 0.152/0.159/0.172/0.017 ms</span><br></pre></td></tr></tbody></table></figure><p>可以看到可以<code>ping</code>通<a href="http://www.baidu.com,时延还算比较ok,几个毫秒量级./">www.baidu.com，时延还算比较OK，几个毫秒量级。</a></p><blockquote><p>这里看一下几个字段的含义，其中：</p><p>56(84) bytes of data：表示默认的数据包长度为56字节；</p><p>time=5.56ms：表示响应的时间，值越小，证明连接越快；</p><p>TTL=52：TTL是Time To Live的缩写，表示DNS记录在DNS服务器上存在的时间，是IP协议包的一个值，告诉路由器啥时候抛弃这个数据包，（大体上可以通过这个值来判断目标类型的操作系统。）</p></blockquote><h3 id="发送指定数目"><a href="#发送指定数目" class="headerlink" title="发送指定数目"></a>发送指定数目</h3><p>可以通过 参数<code>-c</code> 来发送指定数目的包后停止</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ ping www.baidu.com -c 5</span><br><span class="line">PING www.a.shifen.com (115.239.211.112) 56(84) bytes of data.</span><br><span class="line">64 bytes from 115.239.211.112: icmp_seq=1 ttl=52 <span class="keyword">time</span>=6.03 ms</span><br><span class="line">64 bytes from 115.239.211.112: icmp_seq=2 ttl=52 <span class="keyword">time</span>=5.96 ms</span><br><span class="line">64 bytes from 115.239.211.112: icmp_seq=3 ttl=52 <span class="keyword">time</span>=5.79 ms</span><br><span class="line">64 bytes from 115.239.211.112: icmp_seq=4 ttl=52 <span class="keyword">time</span>=5.79 ms</span><br><span class="line">64 bytes from 115.239.211.112: icmp_seq=5 ttl=52 <span class="keyword">time</span>=6.21 ms</span><br><span class="line"></span><br><span class="line"> --- www.a.shifen.com ping statistics ---</span><br><span class="line">5 packets transmitted, 5 received, 0% packet loss, <span class="keyword">time</span> 4007ms</span><br><span class="line">rtt min/avg/max/mdev = 5.791/5.958/6.215/0.186 ms</span><br></pre></td></tr></tbody></table></figure><p>此时将在发送5次数据包以后自动停止，在<strong>Linux</strong>里面，如果不加这个参数，是会一直发送运行的。</p><h3 id="设定发送时间间隔"><a href="#设定发送时间间隔" class="headerlink" title="设定发送时间间隔"></a>设定发送时间间隔</h3><p>可以通过 参数 <code>-i N</code>指定每个<u>N</u>秒发送一次信息，如下将每隔3秒发送一次<code>ping</code>信息。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ ping www.baidu.com -i 3</span><br><span class="line">PING www.a.shifen.com (14.215.177.38) 56(84) bytes of data.</span><br><span class="line">64 bytes from 14.215.177.38 (14.215.177.38): icmp_seq=1 ttl=55 <span class="keyword">time</span>=28.6 ms</span><br><span class="line">64 bytes from 14.215.177.38 (14.215.177.38): icmp_seq=2 ttl=55 <span class="keyword">time</span>=28.6 ms</span><br><span class="line">64 bytes from 14.215.177.38 (14.215.177.38): icmp_seq=3 ttl=55 <span class="keyword">time</span>=28.6 ms</span><br><span class="line">64 bytes from 14.215.177.38 (14.215.177.38): icmp_seq=4 ttl=55 <span class="keyword">time</span>=28.6 ms</span><br><span class="line">64 bytes from 14.215.177.38 (14.215.177.38): icmp_seq=5 ttl=55 <span class="keyword">time</span>=28.6 ms</span><br><span class="line">64 bytes from 14.215.177.38 (14.215.177.38): icmp_seq=6 ttl=55 <span class="keyword">time</span>=28.6 ms</span><br><span class="line">^C</span><br><span class="line"> --- www.a.shifen.com ping statistics ---</span><br><span class="line">6 packets transmitted, 6 received, 0% packet loss, <span class="keyword">time</span> 15041ms</span><br><span class="line">rtt min/avg/max/mdev = 28.650/28.670/28.697/0.139 ms</span><br></pre></td></tr></tbody></table></figure><p>如上，每隔3秒会发送一次，对于需要持续检测或者记录的可以考虑适当加大这个时间间隔。</p><blockquote><p>注意，只有管理员可以设置小于0.2秒的时间间隔。所以这个数值可以是浮点数~</p></blockquote><h3 id="组合使用"><a href="#组合使用" class="headerlink" title="组合使用"></a>组合使用</h3><p>上面的几个例子是可以配合使用的，比如</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ ping www.baidu.com -c 4 -i 5 </span><br><span class="line">PING www.a.shifen.com (14.215.177.39) 56(84) bytes of data.</span><br><span class="line">64 bytes from 14.215.177.39 (14.215.177.39): icmp_seq=1 ttl=55 <span class="keyword">time</span>=29.4 ms</span><br><span class="line">64 bytes from 14.215.177.39 (14.215.177.39): icmp_seq=2 ttl=55 <span class="keyword">time</span>=29.3 ms</span><br><span class="line">64 bytes from 14.215.177.39 (14.215.177.39): icmp_seq=3 ttl=55 <span class="keyword">time</span>=29.4 ms</span><br><span class="line">64 bytes from 14.215.177.39 (14.215.177.39): icmp_seq=4 ttl=55 <span class="keyword">time</span>=29.4 ms</span><br><span class="line"></span><br><span class="line"> --- www.a.shifen.com ping statistics ---</span><br><span class="line">5 packets transmitted, 5 received, 0% packet loss, <span class="keyword">time</span> 20045ms</span><br><span class="line">rtt min/avg/max/mdev = 29.396/29.428/29.461/0.110 ms</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>这个例子为：每个5秒查询一次，一共查询4次，然后退出。</p><h2 id="Linux-ip命令"><a href="#Linux-ip命令" class="headerlink" title="Linux ip命令"></a>Linux ip命令</h2><p>Linux <code>ip</code> 命令与 <code>ifconfig</code> 命令类似，但比 <code>ifconfig</code> 命令更加强大，主要用于显示或设置网络设备。</p><p>已经在Linux 2.2 加入到了内核。所以<code>ip</code>是加强版的网络配置工具，用来替代<code>ifconfig</code>并强化其他功能。</p><p>官方定义为：</p><blockquote><p> ip - show / manipulate routing, devices, policy routing and tunnels</p></blockquote><p>对于这个命令，命令集是相当的多。先说一些基础的，其他就要自己摸索了。</p><p>使用方法为：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ ip [ OPTIONS ] OBJECT { COMMAND | <span class="built_in">help</span> }</span><br><span class="line"></span><br><span class="line">$ ip [ -force ] -batch filename</span><br><span class="line">   </span><br><span class="line"><span class="comment"># OBJECT的取值   </span></span><br><span class="line"><span class="comment"># OBJECT := { link | address | addrlabel | route | rule | neigh | ntable | tunnel | tuntap | maddress | mroute | mrule | monitor | xfrm | netns | l2tp | tcp_metrics | token | macsec }</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># OPTIONS的取值  </span></span><br><span class="line"><span class="comment"># OPTIONS := { -V[ersion] | -h[uman-readable] | -s[tatistics] | -d[etails] | -r[esolve] | -iec | -f[amily] { inet | inet6 | ipx | dnet | link } | -4 | -6 | -I | -D | -B | -0 | -l[oops] { maximum-addr-flush-attempts } | -o[neline] | -rc[vbuf] [size] | -t[imestamp] | -ts[hort] | -n[etns] name | -a[ll] | -c[olor] }</span></span><br></pre></td></tr></tbody></table></figure><p><strong>COMMAND</strong>的值主要取决于<strong>OBJECT</strong>，可能有所不同，一般可以使用<code>add</code>，<code>delete</code>和<code>show</code>（或者<code>list</code>），均可以输入<code>help</code>来进行查询。</p><p>OBJECT中常用的为：</p><ul><li><code>link</code> 网络设备</li><li><code>address</code> 设备上的协议地址</li><li><code>-s, -stats, -statistics</code> 统计化输出</li></ul><h3 id="显示网络设备"><a href="#显示网络设备" class="headerlink" title="显示网络设备"></a>显示网络设备</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 显示网络设备</span></span><br><span class="line">$ ip <span class="built_in">link</span> show</span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN mode DEFAULT group default qlen 1000</span><br><span class="line">    <span class="built_in">link</span>/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">2: eno1: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc mq state UP mode DEFAULT group default qlen 1000</span><br><span class="line">    <span class="built_in">link</span>/ether xx:xx:xx:xx:xx:xx brd ff:ff:ff:ff:ff:ff</span><br><span class="line">3: eno2: &lt;NO-CARRIER,BROADCAST,MULTICAST,UP&gt; mtu 9000 qdisc mq state DOWN mode DEFAULT group default qlen 1000</span><br><span class="line">    <span class="built_in">link</span>/ether xx:xx:xx:xx:xx:xx brd ff:ff:ff:ff:ff:ff</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示IP等更多信息</span></span><br><span class="line">$ ip address show</span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000</span><br><span class="line">    <span class="built_in">link</span>/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">    inet 127.0.0.1/8 scope host lo</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 ::1/128 scope host </span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">2: eno1: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc mq state UP group default qlen 1000</span><br><span class="line">    <span class="built_in">link</span>/ether xx:xx:xx:xx:xx:xx brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 192.168.1.123/24 brd 192.168.254.255 scope global noprefixroute eno1</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 xxxx:xxxx:xxxx:xxxx:xxxx:xxxx:xxxx:xxxx/64 scope global noprefixroute </span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">3: eno2: &lt;NO-CARRIER,BROADCAST,MULTICAST,UP&gt; mtu 9000 qdisc mq state DOWN group default qlen 1000</span><br><span class="line">    <span class="built_in">link</span>/ether xx:xx:xx:xx:xx:xx brd ff:ff:ff:ff:ff:ff</span><br></pre></td></tr></tbody></table></figure><p>命令中的show为默认，也可以直接使用<code>ip link</code>或者<code>ip address</code>，结果一致。</p><h3 id="设置IP地址"><a href="#设置IP地址" class="headerlink" title="设置IP地址"></a>设置IP地址</h3><p>可以通过<code>ip addr add/del xxx.xxx.xxx.xxx dev interface </code>来设置或者删除IP地址。</p><p>如下设置or删除eth0的IP地址。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置IP地址</span></span><br><span class="line">$ ip addr add 192.168.0.1/24 dev eth0 </span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除IP地址</span></span><br><span class="line">$ ip addr del 192.168.0.1/24 dev eth0 </span><br></pre></td></tr></tbody></table></figure><h3 id="启动关闭网卡-1"><a href="#启动关闭网卡-1" class="headerlink" title="启动关闭网卡"></a>启动关闭网卡</h3><p>与ifconfig类似，也使用up与down来进行启动和关闭，具体如下：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 开启网卡</span></span><br><span class="line">$ ip <span class="built_in">link</span> <span class="built_in">set</span> eth0 up             </span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭网卡</span></span><br><span class="line">$ ip <span class="built_in">link</span> <span class="built_in">set</span> eth0 down           </span><br></pre></td></tr></tbody></table></figure><h3 id="统计方便阅读"><a href="#统计方便阅读" class="headerlink" title="统计方便阅读"></a>统计方便阅读</h3><p>选项-s可以统计一些信息方便我们阅读，如下看看网络的情况：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">$ ip -s <span class="built_in">link</span></span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN mode DEFAULT group default qlen 1000</span><br><span class="line">    <span class="built_in">link</span>/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">    RX: bytes  packets  errors  dropped overrun mcast   </span><br><span class="line">    871883256468 251700492 0       0       0       0       </span><br><span class="line">    TX: bytes  packets  errors  dropped carrier collsns </span><br><span class="line">    871883256468 251700492 0       0       0       0       </span><br><span class="line">2: eno1: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc mq state UP mode DEFAULT group default qlen 1000</span><br><span class="line">    <span class="built_in">link</span>/ether xx:xx:xx:xx:xx:xx brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    RX: bytes  packets  errors  dropped overrun mcast   </span><br><span class="line">    64930085920632 50955323447 0       613156  0       472190933 </span><br><span class="line">    TX: bytes  packets  errors  dropped carrier collsns </span><br><span class="line">    17534345850354 17448077191 0       0       0       0       </span><br><span class="line">3: eno2: &lt;NO-CARRIER,BROADCAST,MULTICAST,UP&gt; mtu 9000 qdisc mq state DOWN mode DEFAULT group default qlen 1000</span><br><span class="line">    <span class="built_in">link</span>/ether xx:xx:xx:xx:xx:xx brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    RX: bytes  packets  errors  dropped overrun mcast   </span><br><span class="line">    0          0        0       0       0       0       </span><br><span class="line">    TX: bytes  packets  errors  dropped carrier collsns </span><br><span class="line">    0          0        0       0       0       0  </span><br></pre></td></tr></tbody></table></figure><p>可以看到对输出进行了一些格式化，看起来更直观。</p><h2 id="探索网络连接的netstat"><a href="#探索网络连接的netstat" class="headerlink" title="探索网络连接的netstat"></a>探索网络连接的netstat</h2><p>在Linux系统中，网络是至关重要的部分，而<code>netstat</code>命令是管理和监视网络连接的强大工具之一。</p><p>它提供了关于网络接口和路由表的详细信息，有助于了解网络连接状态、统计信息以及网络协议的使用情况。</p><p>也更方便我们对网络的管理、故障排除以及安全监控等等。</p><h3 id="基本概述"><a href="#基本概述" class="headerlink" title="基本概述"></a>基本概述</h3><p><code>netstat</code>命令比较简单，通过简单的参数组合，可以获得各种网络相关的信息。</p><p>以下是一些常用的参数及其功能：</p><ul><li><code>-a</code>：显示所有连接和监听端口。</li><li><code>-t</code>：仅显示TCP连接。</li><li><code>-u</code>：仅显示UDP连接。</li><li><code>-n</code>：以数字形式显示地址和端口号。</li><li><code>-p</code>：显示进程标识符和程序名称。</li><li><code>-r</code>：显示路由表。</li><li><code>-s</code>：显示统计信息。</li></ul><h2 id="非交互的下载工具-wget"><a href="#非交互的下载工具-wget" class="headerlink" title="非交互的下载工具 wget"></a>非交互的下载工具 wget</h2><p><code>Linux</code>系统中的<code>wget</code>是一个下载文件<span class="github-emoji"><span>📀</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f4c0.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>的命令行工具，特别普遍 。</p><p>对于<code>Linux</code>用户是必不可少的工具，对于经常要下载一些软件或从远程服务器恢复备份到本地服务器，这个命令尤为重要。</p><p><code>wget</code>支持很多协议，比如<code>HTTP</code>，<code>HTTPS</code>和<code>FTP</code>协议，还可以使用<code>HTTP</code>代理。</p><p><code>wget</code>的有诸多特点，比如</p><ul><li>自动下载 <code>wget</code>支持自动下载，即<code>wget</code>可以在用户退出系统的之后在后台执行。这意味着你可以登录系统，启动一个<code>wget</code>下载任务，然后退出系统，<code>wget</code>将在后台执行直到任务完成，这是个牛气冲天的功能。</li><li>完全重建 <code>wget</code> 可以跟踪<code>HTML</code>页面上的链接依次下载来创建远程服务器的本地版本，完全重建原始站点的目录结构。这又常被称作”递归下载”。在递归下载的时候，<code>wget</code> 遵循Robot Exclusion标准(/robots.txt). <code>wget</code>可以在下载的同时，将链接转换成指向本地文件，以方便离线浏览。</li><li>高稳定 <code>wget</code> 非常稳定，它在带宽很窄的情况下和不稳定网络中有很强的适应性.如果是由于网络的原因下载失败，<code>wget</code>会不断地尝试，直到整个文件下载完毕。如果是服务器打断下载过程，它会再次联到服务器上从停止的地方继续下载。这对从那些限定了链接时间的服务器上下载大文件非常有用。</li></ul><h3 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ wget [参数] [URL地址]</span><br></pre></td></tr></tbody></table></figure><p>用于从网络上下载资源，没有指定目录，下载资源会默认为当前目录。<code>wget</code>虽然功能强大，但是使用起来还是比较简单：</p><h3 id="使用范例"><a href="#使用范例" class="headerlink" title="使用范例"></a>使用范例</h3><p><code>wget</code>的命令参数很多，不过常用的为下面几个，详细的可以看进阶。</p><h4 id="使用wget下载单个文件"><a href="#使用wget下载单个文件" class="headerlink" title="使用wget下载单个文件"></a>使用wget下载单个文件</h4><p>比如，我们下载个Ubuntu的最新版本，试下效果如何</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ wget http://releases.ubuntu.com/16.04/ubuntu-16.04-desktop-amd64.iso</span><br></pre></td></tr></tbody></table></figure><p>在下载的过程中会显示进度条，包含（下载完成百分比，已经下载的字节，当前下载速度，剩余下载时间）。</p><h4 id="使用wget-O下载并以不同的文件名保存"><a href="#使用wget-O下载并以不同的文件名保存" class="headerlink" title="使用wget -O下载并以不同的文件名保存"></a>使用wget -O下载并以不同的文件名保存</h4><p>这个对于动态链接的下载比较有用，特别是有些文件的名字实在是太……………….长了</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ wget -O wordpress.zip http://www.ubuntu.com/download.aspx?<span class="built_in">id</span>=1234</span><br></pre></td></tr></tbody></table></figure><h4 id="使用wget-c断点续传"><a href="#使用wget-c断点续传" class="headerlink" title="使用wget -c断点续传"></a>使用wget -c断点续传</h4><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ wget -c http://releases.ubuntu.com/16.04/ubuntu-16.04-desktop-amd64.iso</span><br><span class="line"></span><br><span class="line"><span class="comment"># or</span></span><br><span class="line"></span><br><span class="line">$ wget --<span class="built_in">continue</span> http://releases.ubuntu.com/16.04/ubuntu-16.04-desktop-amd64.iso</span><br></pre></td></tr></tbody></table></figure><p>使用wget -c重新启动下载中断的文件，对于我们下载大文件时突然由于网络等原因中断非常有帮助，我们可以继续接着下载而不是重新下载一个文件。需要继续中断的下载时可以使用-c参数。</p><h4 id="使用wget-o把下载信息存入日志文件"><a href="#使用wget-o把下载信息存入日志文件" class="headerlink" title="使用wget -o把下载信息存入日志文件"></a>使用wget -o把下载信息存入日志文件</h4><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ wget -o download.log URL</span><br></pre></td></tr></tbody></table></figure><p>不希望下载信息直接显示在终端而是在一个日志文件，可以使用，特别注意需要与<code>-O</code>来区分开~</p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;linux中最常用的网络命令&quot;&gt;&lt;a href=&quot;#linux中最常用的网络命令&quot; class=&quot;headerlink&quot; title=&quot;linux中最常用的网络命令&quot;&gt;&lt;/a&gt;linux中最常用的网络命令&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt; 仅个人想法，会持</summary>
      
    
    
    
    <category term="Linux集锦" scheme="http://shaoguangleo.github.io/categories/Linux%E9%9B%86%E9%94%A6/"/>
    
    
    <category term="ifconfig" scheme="http://shaoguangleo.github.io/tags/ifconfig/"/>
    
    <category term="ip" scheme="http://shaoguangleo.github.io/tags/ip/"/>
    
    <category term="ping" scheme="http://shaoguangleo.github.io/tags/ping/"/>
    
    <category term="网络命令" scheme="http://shaoguangleo.github.io/tags/%E7%BD%91%E7%BB%9C%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>linux中最常用的用户信息命令</title>
    <link href="http://shaoguangleo.github.io/2024/01/01/linux-collection-user-information-commands/"/>
    <id>http://shaoguangleo.github.io/2024/01/01/linux-collection-user-information-commands/</id>
    <published>2024-01-01T14:28:00.000Z</published>
    <updated>2025-06-19T13:19:18.873Z</updated>
    
    <content type="html"><![CDATA[<ul><li><a href="ebook/en/content/023-the-groups-command.md">groups</a> - show group memberships</li><li><a href="ebook/en/content/022-the-finger-command.md">finger</a> - shows information about users</li><li><a href="ebook/en/content/048-the-last-command.md">last</a> - displays most recent user logins</li></ul><h1 id="linux中最常用的用户信息命令"><a href="#linux中最常用的用户信息命令" class="headerlink" title="linux中最常用的用户信息命令"></a>linux中最常用的用户信息命令</h1><blockquote><p> 仅个人想法，会持续不间断更新和改进。</p></blockquote><p>用户信息，重中之重。</p><p>虽然21世纪最重要的是人才。</p><p>但对于我们个人而言，用户信息也是极其重要并特别需要留意的。</p><hr><h2 id="还有谁-last"><a href="#还有谁-last" class="headerlink" title="还有谁 last"></a>还有谁 last</h2><p>Linux <code>last</code> 命令用于显示用户最近的登录信息。</p><p>官方定义为：</p><blockquote><p> last, lastb - show listing of last logged in users</p></blockquote><p>通过读取<u>/var/log/wtmp</u>文件来获取这些信息。</p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ last [-R] [-num] [ -n num ] [-adFiowx] [ -f file ] [ -t YYYYMMDDHHMMSS] [name...]  [<span class="built_in">tty</span>...]</span><br></pre></td></tr></tbody></table></figure><p><strong>参数</strong>：</p><ul><li><p><code>-R</code> 省略 hostname 的栏位</p></li><li><p><code>-n</code> 展示前 num 个</p></li><li><p><code>username</code> 展示 username 的登入讯息</p></li><li><p><code>tty</code> 限制登入讯息包含终端机代号</p></li></ul><h3 id="一般使用方法"><a href="#一般使用方法" class="headerlink" title="一般使用方法"></a>一般使用方法</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ last</span><br><span class="line">username2  pts/17       192.168.100.123  Wed Mar 23 22:14   still logged <span class="keyword">in</span></span><br><span class="line">username3  pts/20       localhost:11.0   Wed Mar 23 14:26 - 15:48  (01:21)</span><br><span class="line">username4  pts/23       localhost:11.0   Wed Mar 23 14:26 - 15:48  (01:21)</span><br><span class="line">username4  pts/4        192.168.100.125    Thu Jun 10 18:37 - 22:57  (04:20)</span><br><span class="line">username5  pts/4        192.168.100.125    Thu Jun 10 18:21 - 18:21  (00:00)</span><br><span class="line">username6  pts/9        192.168.100.126    Thu Jun 10 18:11 - 18:20  (00:09)</span><br><span class="line">username7  pts/15       192.168.100.122    Thu Jun 10 18:04 - 23:44 (1+05:40)</span><br><span class="line">username8  pts/14       192.168.100.121    Thu Jun 10 17:59 - 07:50  (13:50)</span><br><span class="line">username9  pts/9        192.168.100.126    Thu Jun 10 17:59 - 18:03  (00:04)</span><br><span class="line"></span><br><span class="line">wtmp begins Thu Jun 10 17:33:14 2013</span><br></pre></td></tr></tbody></table></figure><h3 id="查看最近登陆的三个用户"><a href="#查看最近登陆的三个用户" class="headerlink" title="查看最近登陆的三个用户"></a>查看最近登陆的三个用户</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ last -3</span><br><span class="line"></span><br><span class="line">username2  pts/17       192.168.100.123  Wed Mar 23 22:14   still logged <span class="keyword">in</span></span><br><span class="line">username3  pts/20       localhost:11.0   Wed Mar 23 14:26 - 15:48  (01:21)</span><br><span class="line">username4  pts/23       localhost:11.0   Wed Mar 23 14:26 - 15:48  (01:21)</span><br><span class="line"></span><br><span class="line">wtmp begins Thu Jun 10 17:33:14 2013</span><br></pre></td></tr></tbody></table></figure><h3 id="省略hostname"><a href="#省略hostname" class="headerlink" title="省略hostname"></a>省略hostname</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ last -3 -R</span><br><span class="line">username2  pts/17         Wed Mar 23 22:14   still logged <span class="keyword">in</span></span><br><span class="line">username3  pts/20         Wed Mar 23 14:26 - 15:48  (01:21)</span><br><span class="line">username4  pts/23         Wed Mar 23 14:26 - 15:48  (01:21)</span><br><span class="line"></span><br><span class="line">wtmp begins Thu Jun 10 17:33:14 2013</span><br></pre></td></tr></tbody></table></figure><h3 id="显示最后一列显示主机IP地址"><a href="#显示最后一列显示主机IP地址" class="headerlink" title="显示最后一列显示主机IP地址"></a>显示最后一列显示主机IP地址</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ last -n 5 -a -i</span><br><span class="line">username3  pts/17       Wed Mar 23 22:14   still logged <span class="keyword">in</span>    192.168.100.123</span><br><span class="line">username5  pts/20       Wed Mar 23 14:26 - 15:48  (01:21)     0.0.0.0</span><br><span class="line">username6  pts/23       Wed Mar 23 14:26 - 15:48  (01:21)     0.0.0.0</span><br><span class="line">username7  pts/19       Wed Mar 23 13:46 - 15:48  (02:01)     192.168.100.123</span><br><span class="line">username8  pts/17       Wed Mar 23 13:18 - 15:47  (02:29)     192.168.100.123</span><br><span class="line"></span><br><span class="line">wtmp begins Thu Jun 10 17:33:14 2013</span><br></pre></td></tr></tbody></table></figure><h2 id="我是谁-whoami"><a href="#我是谁-whoami" class="headerlink" title="我是谁 whoami"></a>我是谁 whoami</h2><p>我知道你是谁，但我不知道我是谁，此时<code>whoami</code>可以帮助你，哈哈。</p><p><code>whoami</code>将打印当前用户的名字。与<code>id -un</code>类似。</p><p>官方定义为：</p><blockquote><p>whoami - print effective userid</p></blockquote><p>用法为：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">whoami</span> [option] ..</span><br></pre></td></tr></tbody></table></figure><p>这命令，基本没有参数。</p><p>我暂时。。也没有想到为什么会有这个命令。</p><p>唯一的可能使你找管理员来配置个啥，然后他需要知道你是谁，不，我是谁。</p><p>我看了一下源码，果然简洁：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;config.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pwd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"system.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"die.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"error.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"long-options.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"quote.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* The official name of this program (e.g., no 'g' prefix).  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PROGRAM_NAME <span class="string">"whoami"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AUTHORS proper_name (<span class="string">"Richard Mlynarik"</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">usage</span> <span class="params">(<span class="type">int</span> status)</span></span><br><span class="line">{</span><br><span class="line">  <span class="keyword">if</span> (status != EXIT_SUCCESS)</span><br><span class="line">    emit_try_help ();</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    {</span><br><span class="line">      <span class="built_in">printf</span> (_(<span class="string">"Usage: %s [OPTION]...\n"</span>), program_name);</span><br><span class="line">      <span class="built_in">fputs</span> (_(<span class="string">"\</span></span><br><span class="line"><span class="string">Print the user name associated with the current effective user ID.\n\</span></span><br><span class="line"><span class="string">Same as id -un.\n\</span></span><br><span class="line"><span class="string">\n\</span></span><br><span class="line"><span class="string">"</span>), <span class="built_in">stdout</span>);</span><br><span class="line">      <span class="built_in">fputs</span> (HELP_OPTION_DESCRIPTION, <span class="built_in">stdout</span>);</span><br><span class="line">      <span class="built_in">fputs</span> (VERSION_OPTION_DESCRIPTION, <span class="built_in">stdout</span>);</span><br><span class="line">      emit_ancillary_info (PROGRAM_NAME);</span><br><span class="line">    }</span><br><span class="line">  <span class="built_in">exit</span> (status);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">main</span> <span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">{</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">passwd</span> *<span class="title">pw</span>;</span></span><br><span class="line">  <span class="type">uid_t</span> uid;</span><br><span class="line">  <span class="type">uid_t</span> NO_UID = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  initialize_main (&amp;argc, &amp;argv);</span><br><span class="line">  set_program_name (argv[<span class="number">0</span>]);</span><br><span class="line">  setlocale (LC_ALL, <span class="string">""</span>);</span><br><span class="line">  bindtextdomain (PACKAGE, LOCALEDIR);</span><br><span class="line">  textdomain (PACKAGE);</span><br><span class="line"></span><br><span class="line">  atexit (close_stdout);</span><br><span class="line"></span><br><span class="line">  parse_gnu_standard_options_only (argc, argv, PROGRAM_NAME, PACKAGE_NAME,</span><br><span class="line">                                   Version, <span class="literal">true</span>, usage, AUTHORS,</span><br><span class="line">                                   (<span class="type">char</span> <span class="type">const</span> *) <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (optind != argc)</span><br><span class="line">    {</span><br><span class="line">      error (<span class="number">0</span>, <span class="number">0</span>, _(<span class="string">"extra operand %s"</span>), quote (argv[optind]));</span><br><span class="line">      usage (EXIT_FAILURE);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">  errno = <span class="number">0</span>;</span><br><span class="line">  uid = geteuid ();</span><br><span class="line">  pw = (uid == NO_UID &amp;&amp; errno ? <span class="literal">NULL</span> : getpwuid (uid));</span><br><span class="line">  <span class="keyword">if</span> (!pw)</span><br><span class="line">    die (EXIT_FAILURE, errno, _(<span class="string">"cannot find name for user ID %lu"</span>),</span><br><span class="line">         (<span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span>) uid);</span><br><span class="line">  <span class="built_in">puts</span> (pw-&gt;pw_name);</span><br><span class="line">  <span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>其中使用的即为<code>uid = geteuid ();</code>。</p><h2 id="谁？who"><a href="#谁？who" class="headerlink" title="谁？who"></a>谁？who</h2><p>.. note::<br>  物是人非事事休，欲语泪先流。<br>  李清照《武陵春·春晚》</p><p>知道了我是谁，接下来就要知道谁是谁了。</p><p><code>who</code>将显示谁在登录，显示的内容可能包括用户名、终端登录口，登录的时间等等信息。</p><p>官方定义为：</p><blockquote><p>who - show who is logged on</p></blockquote><p>用法为：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">who</span> [OPTION]... [ FILE | ARG1 ARG2 ]</span><br></pre></td></tr></tbody></table></figure><p>常用的参数为：</p><ul><li><code>-q , --count</code>：只显示登入系统的帐号名称和总人数；</li><li><code>-s</code>：此参数将忽略不予处理，仅负责解决who指令其他版本的兼容性问题；</li><li><code>-a, --all</code>：效果为加上 <code>-b -d --login -p -r -t -T -u</code></li><li><code>-b, --boot</code>：上一次系统的重启时间</li><li><code>-d, --dead</code>：打印dead进程 </li><li><code>-H, --heading</code>：打印每一列的表头</li><li><code>-q, --count</code>：所有登录的用户名以及用户登录的数量</li><li><code>-s, --short</code>：打印USER/LINE/WHEN（默认为这个参数）</li></ul><h3 id="默认使用"><a href="#默认使用" class="headerlink" title="默认使用"></a>默认使用</h3><p>显示当前登录系统的用户</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">who</span>       </span><br><span class="line">user      pts/0  2012-03-02 10:12 </span><br><span class="line">user2     pts/1  2012-03-10 09:12</span><br></pre></td></tr></tbody></table></figure><h3 id="系统的运行时间"><a href="#系统的运行时间" class="headerlink" title="系统的运行时间"></a>系统的运行时间</h3><p>这个信息显示系统自上一次重启后的运行时间。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">who</span> -b</span><br><span class="line">system boot 2012-02-16 14:05</span><br></pre></td></tr></tbody></table></figure><h3 id="显示表头信息"><a href="#显示表头信息" class="headerlink" title="显示表头信息"></a>显示表头信息</h3><p>使用<code>-H</code>或者<code>--heading</code>可以看到表头信息</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">who</span> -H</span><br><span class="line">USER     LINE     WHEN         </span><br><span class="line">user      pts/0  2012-03-02 10:12 </span><br><span class="line">user2     pts/1  2012-03-10 09:12</span><br></pre></td></tr></tbody></table></figure><h3 id="显示登录的人员及总数"><a href="#显示登录的人员及总数" class="headerlink" title="显示登录的人员及总数"></a>显示登录的人员及总数</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">who</span> -q</span><br><span class="line">user1 user1 user2 user2 user3 user4</span><br><span class="line"><span class="comment"># users=6</span></span><br></pre></td></tr></tbody></table></figure><h2 id="什么？谁？w-who-amp-what"><a href="#什么？谁？w-who-amp-what" class="headerlink" title="什么？谁？w (who &amp; what)"></a>什么？谁？w (who &amp; what)</h2><p><code>w</code>可以认为是加强版的<code>who</code>，果然越简洁越强大，就比如<code>less</code>比<code>more</code>是功能更多的。</p><p><code>w</code>不仅可以显示谁在登录，还可以打印他们在做什么。<code>w</code>显示的信息如下：</p><ul><li>登录的用户；</li><li>运行的程序；</li><li>第一行显示的信息：当前时间、系统运行的时间、多少用户登录、系统的负载（分贝为1，5，15分钟）</li></ul><p>官方定义为：</p><blockquote><p> w - Show who is logged on and what they are doing.</p></blockquote><p>用法为：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ w [options] user [...]</span><br></pre></td></tr></tbody></table></figure><p>常用的两个选项为：</p><ul><li><p><code>-h</code> 　不显示各栏位的标题信息列。</p></li><li><p><code>-s</code> 　简洁格式列表，不显示用户登入时间，JCPU或者PCPU的时间</p></li></ul><h3 id="默认的显示"><a href="#默认的显示" class="headerlink" title="默认的显示"></a>默认的显示</h3><p>显示当前用户的登录信息及执行的命令</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ w</span><br><span class="line">16:29:03 up 26 days,  2:49, 6 <span class="built_in">users</span>,  load average: 1.00, 0.97, 0.96</span><br><span class="line">USER     TTY      FROM LOGIN@   IDLE   JCPU   PCPU WHAT</span><br><span class="line">user     pts/4    :1   07Sep21 20days  9:59   1:53m bash</span><br><span class="line">user     pts/0    :2   08Sep21  6days  0.70s  1:53m zsh</span><br><span class="line">user     pts/1    :3   08Sep21 20days  1:13m  1:53m bash</span><br><span class="line">user      :0      :0   15Sep21 6days  27days 21.36s zsh</span><br><span class="line">user     pts/2    :0   15Sep21 14days  0.25s  0.25s zsh</span><br><span class="line">user     pts/3    :3   16Sep21 24:45m  0.22s  0.22s bash</span><br></pre></td></tr></tbody></table></figure><h3 id="不显示标题行"><a href="#不显示标题行" class="headerlink" title="不显示标题行"></a>不显示标题行</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ w -h</span><br><span class="line">16:29:16 up 26 days,  2:49, 6 <span class="built_in">users</span>,  load average: 1.20, 0.67, 0.76</span><br><span class="line">USER     TTY      FROM  LOGIN@   IDLE   JCPU   PCPU WHAT</span><br><span class="line">user     pts/4    :1    07Sep21 20days  9:59   1:53m bash</span><br><span class="line">user     pts/0    :2    08Sep21  6days  0.70s  1:53m zsh</span><br><span class="line">user     pts/1    :3    08Sep21 20days  1:13m  1:53m bash</span><br><span class="line">user      :0      :0    15Sep21 6days  27days 21.36s zsh</span><br><span class="line">user     pts/2    :0    15Sep21 14days  0.25s  0.25s zsh</span><br><span class="line">user     pts/3    :3    16Sep21 24:45m  0.22s  0.22s bash</span><br></pre></td></tr></tbody></table></figure><h3 id="简洁模式显示"><a href="#简洁模式显示" class="headerlink" title="简洁模式显示"></a>简洁模式显示</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ w -s</span><br><span class="line">16:29:26 up 26 days,  2:49, 6 <span class="built_in">users</span>,  load average: 1.50, 0.67, 0.36</span><br><span class="line">USER     TTY      FROM    IDLE   WHAT</span><br><span class="line">user     pts/4    :1     20days  bash</span><br><span class="line">user     pts/0    :2      6days  zsh</span><br><span class="line">user     pts/1    :3     20days  bash</span><br><span class="line">user      :0      :0     6days   zsh</span><br><span class="line">user     pts/2    :0     14days  zsh</span><br><span class="line">user     pts/3    :3     24:45m  bash</span><br></pre></td></tr></tbody></table></figure><h2 id="不要告诉别人的passwd"><a href="#不要告诉别人的passwd" class="headerlink" title="不要告诉别人的passwd"></a>不要告诉别人的passwd</h2><p><code>passwd</code>用于创建或者更新用户密码，是管理员必备的命令之一。</p><p>这个命令最终的实现是通过调用Linux-PAM 和Libuser API来实现的。</p><p>官方的定义为：</p><blockquote><p>passwd - update user’s authentication tokens</p></blockquote><p>使用的方法为：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ passwd [-k] [-l] [-u [-f]] [-d] [-e] [-n mindays] [-x maxdays] [-w warndays] [-i inactivedays] [-S] [--stdin] [username]</span><br></pre></td></tr></tbody></table></figure><p>其中很常用的options为：</p><ul><li><code>-S, --status</code>：显示密码的状态信息</li><li><code>-d, --delete</code>：删除用户密码，此时该用户将处于无密码状态</li></ul><p>不太常用的options为：</p><ul><li><code>--stdin</code>：可以通过标准输入，亦可以为一个pipe</li><li><code>-l, --lock</code>：锁定账号，不过也不是完全锁定，因为用户可以通过ssh key来继续访问</li><li><code>-u, --unlock</code>：与上面的<code>-l</code>选项相反，属于解锁用户</li><li><code>-w, --warning DAYS</code>：口令到期前通知用户，具备password lifetime的才支持</li></ul><h3 id="修改或更新密码"><a href="#修改或更新密码" class="headerlink" title="修改或更新密码"></a>修改或更新密码</h3><p>这个是最常用的用法，用于设置或者修改更新用户密码</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">sudo</span> passwd user  <span class="comment">#设置用户user的密码</span></span><br><span class="line">Enter new UNIX password:  <span class="comment">#输入新密码，输入的密码不显示</span></span><br><span class="line">Retype new UNIX password:  <span class="comment">#再次输入确认密码</span></span><br><span class="line">passwd: password updated successfully</span><br><span class="line"><span class="comment"># 此时设置成功</span></span><br></pre></td></tr></tbody></table></figure><h3 id="删除用户密码"><a href="#删除用户密码" class="headerlink" title="删除用户密码"></a>删除用户密码</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">sudo</span> passwd -d user </span><br><span class="line">passwd: password expiry information changed.</span><br></pre></td></tr></tbody></table></figure><p>此时用户处于无密码的状态，很类似最近说的，没有密码就是最安全的密码。</p><h3 id="查看密码的状态"><a href="#查看密码的状态" class="headerlink" title="查看密码的状态"></a>查看密码的状态</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">sudo</span> passwd -S user</span><br><span class="line">[<span class="built_in">sudo</span>] password <span class="keyword">for</span> oper: </span><br><span class="line">user PS 2013-02-11 0 99999 7 -1 (Password <span class="built_in">set</span>, SHA512 crypt.)</span><br></pre></td></tr></tbody></table></figure><p>​      </p><p>说到密码，有两个比较<strong>重要的原则</strong>：</p><ol><li>保护好你的密码，不写下来而是记在脑海里，定时修改；</li><li>选择一个很难猜的密码，而不是最容易被攻破的top密码；</li></ol><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;ebook/en/content/023-the-groups-command.md&quot;&gt;groups&lt;/a&gt; - show group memberships&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;ebook/en/content/022-the</summary>
      
    
    
    
    <category term="Linux集锦" scheme="http://shaoguangleo.github.io/categories/Linux%E9%9B%86%E9%94%A6/"/>
    
    
    <category term="last" scheme="http://shaoguangleo.github.io/tags/last/"/>
    
    <category term="passwd" scheme="http://shaoguangleo.github.io/tags/passwd/"/>
    
    <category term="w" scheme="http://shaoguangleo.github.io/tags/w/"/>
    
    <category term="who" scheme="http://shaoguangleo.github.io/tags/who/"/>
    
    <category term="whoami" scheme="http://shaoguangleo.github.io/tags/whoami/"/>
    
    <category term="用户信息" scheme="http://shaoguangleo.github.io/tags/%E7%94%A8%E6%88%B7%E4%BF%A1%E6%81%AF/"/>
    
  </entry>
  
  <entry>
    <title>linux中最常用的搜索命令</title>
    <link href="http://shaoguangleo.github.io/2023/12/27/linux-collection-search-commands/"/>
    <id>http://shaoguangleo.github.io/2023/12/27/linux-collection-search-commands/</id>
    <published>2023-12-27T14:22:00.000Z</published>
    <updated>2025-06-19T13:19:18.872Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux中最常用的搜索命令"><a href="#Linux中最常用的搜索命令" class="headerlink" title="Linux中最常用的搜索命令"></a>Linux中最常用的搜索命令</h1><blockquote><p> 仅个人想法，会持续不间断更新和改进。</p></blockquote><p>在Linux的庞大世界中，搜索犹如明灯，可以拨开云雾见青天，照亮我们前行大道路。</p><p>无论你是在浩瀚的代码库中搜索一个特定的函数，还是在庞大的文件系统中寻找一个文件，搜索命令着实是不可或缺尤为重要的工具。</p><p>而其中最绕不开的当属以下几个。</p><hr><h2 id="一切皆可查的-find"><a href="#一切皆可查的-find" class="headerlink" title="一切皆可查的 find"></a>一切皆可查的 find</h2><p><code>find</code>命令用来在指定目录下查找文件，功能相当之强大。</p><p>官方定义为：</p><blockquote><p>find - search for files in a directory hierarchy</p></blockquote><p>Linux的哲学是<strong>一切皆文件</strong>，那么find的使命就是<strong>一切皆可查</strong>。</p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p>使用语法为：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ find [-H] [-L] [-P] [-D debugopts] [-Olevel] [path...] [expression]</span><br></pre></td></tr></tbody></table></figure><p>比较常用的几个参数为：</p><ul><li><code>-exec &lt;执行指令&gt;</code>：假设find指令的回传值为True，就执行该指令；</li><li><code>-size &lt;文件大小&gt;</code>：查找符合指定的文件大小的文件；</li><li><code>-mtime &lt;24小时&gt;</code>：查找在指定时间曾被更改过的文件或目录，单位以24小时计算；</li><li><code>-name&lt;范本样式&gt;</code>：指定字符串作为寻找文件或目录的范本样式；</li><li><code>-type &lt;文件类型&gt;</code>：只寻找符合指定的文件类型的文件；</li></ul><h3 id="无参数"><a href="#无参数" class="headerlink" title="无参数"></a>无参数</h3><p>如果使用该命令时，不设置任何参数，则<code>find</code>命令将在当前目录下查找子目录与文件,并且将查找到的子目录和文件全部进行显示。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">ls</span> -l</span><br><span class="line">total 310M</span><br><span class="line">-rw-rw-r-- 1 user user  10M Mar 21 20:01 a</span><br><span class="line">drwxrwxr-x 2 user user   22 Mar 21 20:01 aa</span><br><span class="line">-rw-rw-r-- 1 user user 100M Mar 21 20:01 b</span><br><span class="line">-rw-rw-r-- 1 user user 200M Mar 21 20:01 c</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$ find </span><br><span class="line">.</span><br><span class="line">./a</span><br><span class="line">./b</span><br><span class="line">./c</span><br><span class="line">./test</span><br></pre></td></tr></tbody></table></figure><h3 id="查找小于，等于和大于100MB的文件"><a href="#查找小于，等于和大于100MB的文件" class="headerlink" title="查找小于，等于和大于100MB的文件"></a>查找小于，等于和大于100MB的文件</h3><p>通过-size大小来查找文件</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ find . -size -100M</span><br><span class="line">.</span><br><span class="line">./a</span><br><span class="line">./aa</span><br><span class="line">$ find . -size 100M</span><br><span class="line">./b</span><br><span class="line">$ find . -size +100M</span><br><span class="line">./c</span><br><span class="line">./aa/d</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h3 id="查找多长时间修改过"><a href="#查找多长时间修改过" class="headerlink" title="查找多长时间修改过"></a>查找多长时间修改过</h3><p>可以通过参数-mtime来查找文件的修改时间，比如如下可以查找当前目录下最近60天没有被修改的文件。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ find . -mtime +60</span><br><span class="line"></span><br><span class="line"><span class="comment"># 最近2天以内未修改</span></span><br><span class="line">$ find . –mtime -2</span><br></pre></td></tr></tbody></table></figure><h3 id="稍微复杂但是很有用的命令"><a href="#稍微复杂但是很有用的命令" class="headerlink" title="稍微复杂但是很有用的命令"></a>稍微复杂但是很有用的命令</h3><p> 我经常把 <code>find</code> 命令和他的选项 <code>exec</code>一起使用，比如我想查找一个目录中的所有文件并将其更改其权限。可以通过以下简单命令完成：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ find /path/ -<span class="built_in">type</span> f -<span class="built_in">exec</span> <span class="built_in">chmod</span> 644 {} \;</span><br></pre></td></tr></tbody></table></figure><p>这个命令会递归搜索指定目录内<u>/path/</u>下的所有文件，并对找到的文件执行 <code>chmod</code> 命令。</p><h2 id="精准快速定位的locate"><a href="#精准快速定位的locate" class="headerlink" title="精准快速定位的locate"></a>精准快速定位的locate</h2><p>.. note::</p><p>  众里寻他千百度，蓦然回首，那人却在灯火阑珊处<br>  -李煜</p><p>Linux <code>locate</code>命令用于查找符合条件的文档、程序、目录等等。这个命令会在数据库中查找符合条件的各种信息。</p><p>一般情况我们只需要输入 <code>locate name</code> 即可查找。</p><p>官方定义为：</p><blockquote><p><code>locate</code> - list files in databases that match a pattern</p></blockquote><p>使用方法为：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ locate  [-d  path  |  --database=path]  [-e  | -E | --[non-]existing] [-i | --ignore-case] [-0 | --null] [-c |</span><br><span class="line">       --count] [-w | --wholename] [-b | --<span class="built_in">basename</span>] [-l N | --<span class="built_in">limit</span>=N] [-S | --statistics] [-r | --regex ] [--regex‐</span><br><span class="line">       <span class="built_in">type</span>  R] [--max-database-age D] [-P | -H | --nofollow] [-L | --follow] [--version] [-A | --all] [-p | --<span class="built_in">print</span>]</span><br><span class="line">       [--<span class="built_in">help</span>] pattern...</span><br></pre></td></tr></tbody></table></figure><p>看着很复杂，不过常用的参数倒是不多，基本为：</p><ul><li><code>-n</code> :  至多显示 n个输出。</li><li><code>-i, --ignore-case</code> : 忽略大小写</li></ul><h3 id="默认无参数"><a href="#默认无参数" class="headerlink" title="默认无参数"></a>默认无参数</h3><p>默认情况下，<code>locate</code>直接跟上需要查找的信息就可以了，如下所示：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">$ locate set_vis.cpp</span><br><span class="line">/home/user/mycode/src/set_vis.cpp</span><br><span class="line"></span><br><span class="line"><span class="comment"># 以查找apropos为例</span></span><br><span class="line">$ locate apropos</span><br><span class="line">/usr/bin/apropos</span><br><span class="line">/usr/local/difmap/help/apropos.hlp</span><br><span class="line">/usr/share/emacs/24.3/lisp/apropos.elc</span><br><span class="line">/usr/share/man/de/man1/apropos.1.gz</span><br><span class="line">/usr/share/man/es/man1/apropos.1.gz</span><br><span class="line">/usr/share/man/fr/man1/apropos.1.gz</span><br><span class="line">/usr/share/man/id/man1/apropos.1.gz</span><br><span class="line">/usr/share/man/it/man1/apropos.1.gz</span><br><span class="line">/usr/share/man/ja/man1/apropos.1.gz</span><br><span class="line">/usr/share/man/man1/apropos.1.gz</span><br><span class="line">/usr/share/man/nl/man1/apropos.1.gz</span><br><span class="line">/usr/share/man/pl/man1/apropos.1.gz</span><br><span class="line">/usr/share/man/ru/man1/apropos.1.gz</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h3 id="太多需要简单化"><a href="#太多需要简单化" class="headerlink" title="太多需要简单化"></a>太多需要简单化</h3><p>如果输出的信息很多，仅仅希望看到前面的几个，使用<code>-n</code>参数既可</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 仅仅查看前的3个</span></span><br><span class="line">$ locate -n 3 apropos</span><br><span class="line">/usr/bin/apropos</span><br><span class="line">/usr/local/difmap/help/apropos.hlp</span><br><span class="line">/usr/share/emacs/24.3/lisp/apropos.elc</span><br></pre></td></tr></tbody></table></figure><h3 id="不区分大小写"><a href="#不区分大小写" class="headerlink" title="不区分大小写"></a>不区分大小写</h3><p>部分情况下，可能有大小写混淆的情况，此时使用<code>-i</code>参数既可</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ $ locate -i set_vis.cpp</span><br><span class="line">/home/user/mycode/src/set_vis.cpp</span><br><span class="line">/home/user/mycode_CPP/src/set_VIS.cpp</span><br></pre></td></tr></tbody></table></figure><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><p>不过刚按照的系统，这个命令并不一定有输出，主要是因为<code>locate</code> 与 <code>find</code> 不同， <code> find</code> 直接在硬盘找，而<code>locate</code> 只在数据库中查找。</p><p>这个数据库在CentOS系统默认的为 <u>/var/lib/mlocate/mlocate.db</u> 中，所以<code> locate</code> 的查找会比较快，但并一定是实时的，而是以数据库的更新为准。</p><p>可以通过下面的命令手工升级数据库 ，命令为：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ updatedb</span><br></pre></td></tr></tbody></table></figure><p>然后就可以使用了。</p><h2 id="文件内容搜索利器-grep"><a href="#文件内容搜索利器-grep" class="headerlink" title="文件内容搜索利器 - grep"></a>文件内容搜索利器 - grep</h2><p>Linux <code>grep</code> 命令用于查找文件里符合条件的字符串。</p><p>官方定义为：</p><blockquote><p><code>grep</code>, <code>egrep</code>, <code>fgrep</code> - print lines matching a pattern</p></blockquote><p>grep支持正则表达式，是一个强大的文本搜索工具。</p><h3 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h3><p>语法也挺复杂，因为功能确实很强大。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ grep [OPTION...] PATTERNS [FILE...]</span><br><span class="line">$ grep [OPTION...] -e PATTERNS ... [FILE...]      <span class="comment"># 使用egrep</span></span><br><span class="line">$ grep [OPTION...] -f PATTERN_FILE ... [FILE...]  <span class="comment"># 使用fgrep</span></span><br></pre></td></tr></tbody></table></figure><p>常用的参数为：</p><ul><li><strong>-r 或 –recursive</strong> : 此参数的效果和指定”-d recurse”参数相同</li><li><strong>-v 或 –invert-match</strong> : 显示不包含匹配文本的所有行</li><li><strong>-i 或 –ignore-case</strong> : 忽略字符大小写的差别</li><li><strong>-n 或 –line-number</strong> : 在显示符合样式的那一行之前，标示出该行的列数编号。</li></ul><p>假定有如下3个文件，1个文件夹，内容如下：</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">a</span></span><br><span class="line">    This is <span class="selector-tag">a</span></span><br><span class="line">    Hello <span class="selector-tag">a</span></span><br><span class="line">    </span><br><span class="line"><span class="selector-tag">b</span> </span><br><span class="line">    this is <span class="selector-tag">b</span></span><br><span class="line">    Hello <span class="selector-tag">b</span></span><br><span class="line">c </span><br><span class="line">    This is c</span><br><span class="line">    Hello c</span><br><span class="line"></span><br><span class="line">d/d </span><br><span class="line">    This is d</span><br><span class="line">    Hello d</span><br></pre></td></tr></tbody></table></figure><h3 id="默认无参数-1"><a href="#默认无参数-1" class="headerlink" title="默认无参数"></a>默认无参数</h3><p>在当前目录搜索包含<strong>is</strong>字符串，可以看到**<u>a/b/c</u>**三个文件均有输出，而<u>d</u>因为是目录，暂时无输出。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ grep is *</span><br><span class="line">a:This is a</span><br><span class="line">b:this is b</span><br><span class="line">c:This is c</span><br><span class="line">grep: d: Is a directory</span><br></pre></td></tr></tbody></table></figure><h3 id="增加文件夹"><a href="#增加文件夹" class="headerlink" title="增加文件夹"></a>增加文件夹</h3><p>与其他命令类似，增加<code>-r</code>参数，递归搜索</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ grep -r is *</span><br><span class="line">a:This is a</span><br><span class="line">b:this is b</span><br><span class="line">c:This is c</span><br><span class="line">d/d:This is d</span><br></pre></td></tr></tbody></table></figure><h3 id="反向查找"><a href="#反向查找" class="headerlink" title="反向查找"></a>反向查找</h3><p>在某些情况下，或许正想找到不包含某些字符串的内容，如下：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ grep -rv is *</span><br><span class="line">a:Hello a</span><br><span class="line">b:Hello b</span><br><span class="line">c:Hello c</span><br><span class="line">d/d:Hello d</span><br></pre></td></tr></tbody></table></figure><p>此时可以看到，不包含<strong>is</strong>的内容显示了出来。</p><h3 id="不区分大小写-1"><a href="#不区分大小写-1" class="headerlink" title="不区分大小写"></a>不区分大小写</h3><p>而某些情况下，或许我们希望找到不区分大小写的内容，比如对于<u>This/this</u>而言：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ grep -r This *</span><br><span class="line">a:This is a</span><br><span class="line">c:This is c</span><br><span class="line">d/d:This is d</span><br><span class="line"></span><br><span class="line">$ grep -ri This *</span><br><span class="line">a:This is a</span><br><span class="line">b:this is b</span><br><span class="line">c:This is c</span><br><span class="line">d/d:This is d</span><br></pre></td></tr></tbody></table></figure><p>可以看到此时有可能笔误，或者其他原因的b文件已经被找到了。</p><h3 id="显示行数，精准定位"><a href="#显示行数，精准定位" class="headerlink" title="显示行数，精准定位"></a>显示行数，精准定位</h3><p>   如果文件内容比较多，此时显示内容在哪一行，是很重要的，加上<code>-n</code>参数既可解决。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ grep -rn This *</span><br><span class="line">a:1:This is a</span><br><span class="line">c:1:This is c</span><br><span class="line">d/d:1:This is d</span><br></pre></td></tr></tbody></table></figure><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Linux中最常用的搜索命令&quot;&gt;&lt;a href=&quot;#Linux中最常用的搜索命令&quot; class=&quot;headerlink&quot; title=&quot;Linux中最常用的搜索命令&quot;&gt;&lt;/a&gt;Linux中最常用的搜索命令&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt; 仅个人想法，会持</summary>
      
    
    
    
    <category term="Linux集锦" scheme="http://shaoguangleo.github.io/categories/Linux%E9%9B%86%E9%94%A6/"/>
    
    
    <category term="search" scheme="http://shaoguangleo.github.io/tags/search/"/>
    
    <category term="find" scheme="http://shaoguangleo.github.io/tags/find/"/>
    
    <category term="locate" scheme="http://shaoguangleo.github.io/tags/locate/"/>
    
  </entry>
  
  <entry>
    <title>linux中最常用的目录导航命令</title>
    <link href="http://shaoguangleo.github.io/2023/12/17/linux-collection-directory-navigation-commands/"/>
    <id>http://shaoguangleo.github.io/2023/12/17/linux-collection-directory-navigation-commands/</id>
    <published>2023-12-17T14:28:00.000Z</published>
    <updated>2025-06-19T13:19:18.871Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux中最常用的目录导航命令"><a href="#Linux中最常用的目录导航命令" class="headerlink" title="Linux中最常用的目录导航命令"></a>Linux中最常用的目录导航命令</h1><blockquote><p> 仅个人想法，会持续不间断更新和改进。</p></blockquote><p>在Linux世界中，为了更加高效地浏览和定位文件，需要一些常用的目录导航命令。 </p><hr><h2 id="探索未知世界的cd"><a href="#探索未知世界的cd" class="headerlink" title="探索未知世界的cd"></a>探索未知世界的cd</h2><p>.. note::<br>  月桥花院，琐窗朱户，只有春知处。<br>  宋 辛弃疾《青玉案·元夕》</p><p><code>cd</code> 命令应该是除了 <code>ls</code> 命令外用的最多的命令了。除非你大门不出二门不迈，做个大家闺秀。</p><p><code>cd</code> 命令的含义为</p><blockquote><p> cd - change directory</p></blockquote><p>可以让我们访问不同的文件夹。</p><p>最简单的用法为：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> /the/path/you/want/to/go/</span><br></pre></td></tr></tbody></table></figure><blockquote><p> 接下来说一些技巧，让效率加倍。</p></blockquote><p>让cd命令对参数大小写不敏感</p><p>如果你需要同时显示大写和小写的目录名（即便是你给的参数只是小写的），执行下面的<code>bind</code>命令，此时就可以避免<code>Linux</code>和<code>linux</code>的尴尬。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">bind</span> <span class="string">"set completion-ignore-case on"</span></span><br></pre></td></tr></tbody></table></figure><h3 id="进入刚才的目录"><a href="#进入刚才的目录" class="headerlink" title="进入刚才的目录"></a>进入刚才的目录</h3><p>想要进入刚才进入的地方（目测没有很多人再用，但是真的很好用）运行：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> –</span><br></pre></td></tr></tbody></table></figure><h3 id="快速返回家目录"><a href="#快速返回家目录" class="headerlink" title="快速返回家目录"></a>快速返回家目录</h3><p>需要快速地回到你的家目录，输入<code>cd</code>即可，这里其实不用一级一级的进入</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span></span><br></pre></td></tr></tbody></table></figure><h3 id="进入某用户的家目录"><a href="#进入某用户的家目录" class="headerlink" title="进入某用户的家目录"></a>进入某用户的家目录</h3><p>这个需要你有root权限</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~username</span><br></pre></td></tr></tbody></table></figure><p>进入username的家目录。</p><blockquote><p>这些是一些比较基础和入门的，还有一些高级一点的，这些技巧可能用的比较少，不过也是很有帮助的。</p></blockquote><h3 id="结合CDPATH的妙用"><a href="#结合CDPATH的妙用" class="headerlink" title="结合CDPATH的妙用"></a>结合CDPATH的妙用</h3><p>变量CDPATH定义了目录的搜索路径：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">export</span> CDPATH=/the/path/you/add/:/another/path/</span><br></pre></td></tr></tbody></table></figure><p>现在，不用输入<code>cd /the/path/you/add/hello/</code> 这样长了，我可以直接输入下面的命令进入 <code>/the/path/you/add/hello/</code>：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> html</span><br></pre></td></tr></tbody></table></figure><h3 id=""><a href="#" class="headerlink" title="!$"></a>!$</h3><p>这个命令目测，用的人不多，其实比较有用，且有效。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> !$</span><br></pre></td></tr></tbody></table></figure><p>表明的意思是将上一个命令的参数作为cd的参数来使用。</p><h3 id="用shopt-–s-cdspell自动纠正cd命令的目录名输入错误"><a href="#用shopt-–s-cdspell自动纠正cd命令的目录名输入错误" class="headerlink" title="用shopt –s cdspell自动纠正cd命令的目录名输入错误"></a>用shopt –s cdspell自动纠正cd命令的目录名输入错误</h3><p>使用<code>shopt -s cdspell</code>可以自动修正<code>cd</code>时拼写错误的目录名。</p><p>如果你在输入时经常犯些错误，这个命令是很有用的。详见以下示例：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cd /etc/mall</span></span><br><span class="line"></span><br><span class="line">-bash: <span class="built_in">cd</span>: /etc/mall: No such file or directory</span><br><span class="line"></span><br><span class="line"><span class="comment"># shopt -s cdspell</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># cd /etc/mall</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># pwd</span></span><br><span class="line"></span><br><span class="line">/etc/mail</span><br></pre></td></tr></tbody></table></figure><blockquote><p> 注: 当我错误的把mail敲成了mall，用这个命令mall就自动被换成了mail</p></blockquote><h2 id="最常用的且没有之一的-ls"><a href="#最常用的且没有之一的-ls" class="headerlink" title="最常用的且没有之一的  ls"></a>最常用的且没有之一的  ls</h2><p>.. note::<br>  寻寻觅觅，冷冷清清，凄凄惨惨戚戚。<br>  宋 李清照《声声慢·寻寻觅觅》</p><p>如果<code>linux</code>命令来个排名，<code>ls</code>命令应该是最常用的命令，除非你像<em>黄蓉</em>的母亲，有过目不忘的本领，惹得黄药师抱憾终身。</p><p><code>ls</code>命令是<code>list</code>的缩写，通过ls命令，我们可以查看目录的内容，确定各种重要文件和目录的属性。</p><h3 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h3><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls <span class="selector-attr">[参数]</span> <span class="selector-attr">[路径]</span></span><br></pre></td></tr></tbody></table></figure><h3 id="不加任何参数"><a href="#不加任何参数" class="headerlink" title="不加任何参数"></a>不加任何参数</h3><p>如果不加任何参数，默认列出当前目录的内容。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">ls</span> /etc/sysconfig/network-scripts</span><br><span class="line">ifcfg-em1</span><br><span class="line">ifcfg-em2</span><br><span class="line">ifcfg-em3</span><br><span class="line">ifcfg-em4   </span><br><span class="line">....</span><br></pre></td></tr></tbody></table></figure><h3 id="使用-l显示更多细节"><a href="#使用-l显示更多细节" class="headerlink" title="使用-l显示更多细节"></a>使用-l显示更多细节</h3><p>-l 就是使用long listing format长格式，来显示更多的内容信息。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">ls</span> -l /etc/sysconfig/network-scripts</span><br><span class="line">total 264</span><br><span class="line">-rw-r--r--. 1 root root   341 Nov 30 10:56 ifcfg-em1</span><br><span class="line">-rw-r--r--. 1 root root   294 May 13  2016 ifcfg-em2</span><br><span class="line">-rw-r--r--. 1 root root   272 May 10  2016 ifcfg-em3</span><br><span class="line">-rw-r--r--. 1 root root   272 May 10  2016 ifcfg-em4</span><br><span class="line">......</span><br></pre></td></tr></tbody></table></figure><h3 id="使用-t按照时间排序"><a href="#使用-t按照时间排序" class="headerlink" title="使用-t按照时间排序"></a>使用-t按照时间排序</h3><p>如果希望看到最近创建的文件，就需要用到-t参数了。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">ls</span> -lt /etc/sysconfig/network-scripts/</span><br><span class="line">total 264</span><br><span class="line">-rw-r--r--. 1 root root   341 Nov 30 10:56 ifcfg-em1</span><br><span class="line">-rw-r--r--. 1 root root   294 May 13  2016 ifcfg-em2</span><br><span class="line">-rw-r--r--. 1 root root   272 May 10  2016 ifcfg-em4</span><br><span class="line">-rw-r--r--. 1 root root   272 May 10  2016 ifcfg-em3</span><br><span class="line">...</span><br></pre></td></tr></tbody></table></figure><h3 id="使用-r按照时间逆序"><a href="#使用-r按照时间逆序" class="headerlink" title="使用-r按照时间逆序"></a>使用-r按照时间逆序</h3><p>如果希望删除很早以前的文件，看到最早创建的文件，就需要用到-r参数了。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">ls</span> -ltr /etc/sysconfig/network-scripts/</span><br><span class="line">total 264</span><br><span class="line">...</span><br><span class="line">-rw-r--r--. 1 root root   272 May 10  2016 ifcfg-em3</span><br><span class="line">-rw-r--r--. 1 root root   272 May 10  2016 ifcfg-em4</span><br><span class="line">-rw-r--r--. 1 root root   294 May 13  2016 ifcfg-em2</span><br><span class="line">-rw-r--r--. 1 root root   341 Nov 30 10:56 ifcfg-em1</span><br></pre></td></tr></tbody></table></figure><h3 id="使用-S根据文件大小排序"><a href="#使用-S根据文件大小排序" class="headerlink" title="使用-S根据文件大小排序"></a>使用-S根据文件大小排序</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">ls</span> -lS /etc/sysconfig/network-scripts/</span><br><span class="line">total 264</span><br><span class="line">...</span><br><span class="line">-rw-r--r--. 1 root root   341 Nov 30 10:56 ifcfg-em1</span><br><span class="line">-rw-r--r--. 1 root root   294 May 13  2016 ifcfg-em2</span><br><span class="line">-rw-r--r--. 1 root root   272 May 10  2016 ifcfg-em3</span><br><span class="line">-rw-r--r--. 1 root root   272 May 10  2016 ifcfg-em4</span><br></pre></td></tr></tbody></table></figure><h2 id="查看目录命令pwd"><a href="#查看目录命令pwd" class="headerlink" title="查看目录命令pwd"></a>查看目录命令pwd</h2><p><code>pwd</code>命令的作用是查看当前目录，没有参数，输入后回车即可显示当前绝对路径。</p><p>官方定义为：</p><blockquote><p>pwd - print name of current/working directory</p></blockquote><p> 所以<code>pwd</code>是<strong>P</strong>rint <strong>W</strong>orking  <strong>D</strong>irectory第一个字的缩写。</p><p>唯二需要了解的参数如下：</p><ul><li><code>-L</code>, <code>--logical</code>：打印逻辑路径，与<code>pwd</code>一致</li><li><code>-P</code>, <code>--physical</code>：打印物理路径，这里可以从超级链接直达原处</li></ul><h3 id="实例展示"><a href="#实例展示" class="headerlink" title="实例展示"></a>实例展示</h3><p>此时比如我们进入一个目录，然后在打印出来，如下：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> /etc/sysconfig/network-scripts/</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">pwd</span></span><br><span class="line">/etc/sysconfig/network-scripts</span><br></pre></td></tr></tbody></table></figure><blockquote><p>可以看到pwd将输出完全路径</p></blockquote><h3 id="逻辑与物理路径"><a href="#逻辑与物理路径" class="headerlink" title="逻辑与物理路径"></a>逻辑与物理路径</h3><p>比如如下：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">pwd</span></span><br><span class="line">/opt/test</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">ls</span> -l</span><br><span class="line">总用量 1</span><br><span class="line">lrwxrwxrwx  1 root root   14 Jan 15 2012 <span class="built_in">dir</span> -&gt; <span class="built_in">source</span>/dir</span><br><span class="line">drwxrwxrwx  1 root root   14 Jan 15 2012 <span class="built_in">source</span></span><br></pre></td></tr></tbody></table></figure><p>可以看到此时的路径在<u>/opt/test/</u>里面有两个目录<u>source</u>和<u>dir</u>，其中<u>dir</u>链接到<u>source</u>里面的dir。</p><p>接下来对比一下-L和-P的区别。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> <span class="built_in">dir</span></span><br><span class="line"></span><br><span class="line">$ <span class="built_in">pwd</span></span><br><span class="line">/opt/test/dir</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">pwd</span> -L</span><br><span class="line">/opt/test/dir</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">pwd</span> -P</span><br><span class="line">/opt/test/source/dir</span><br></pre></td></tr></tbody></table></figure><p>从上面的输出可以发现，<code>-P</code>参数会显示文件最原始的路径；而<code>-L</code>则是逻辑上的路径。</p><h2 id="Linux-tree命令"><a href="#Linux-tree命令" class="headerlink" title="Linux tree命令"></a>Linux tree命令</h2><p>Linux <code>tree</code>命令以树状图列出目录的内容。</p><p>执行<code>tree</code>指令，它会列出指定目录下的所有文件，包括子目录里的文件。</p><p>官方定义为：</p><blockquote><p><code>tree</code> - list contents of directories in a tree-like format.</p></blockquote><p>使用方法为：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ tree  [-acdfghilnpqrstuvxACDFQNSUX] [-L level [-R]] [-H baseHREF] [-T title] [-o filename] [--nolinks] [-P pattern] [-I pat‐</span><br><span class="line">       tern] [--inodes] [--device]  [--noreport]  [--dirsfirst]  [--version]  [--<span class="built_in">help</span>]  [--filelimit  <span class="comment">#]  [--si]  [--prune]  [--du]</span></span><br><span class="line">       [--timefmt format] [--matchdirs] [--fromfile] [--] [directory ...]</span><br></pre></td></tr></tbody></table></figure><p>参数比较多，也比较复杂。其中常用的选项为：</p><ul><li><code>-d</code> 显示目录名称而非内容。</li><li><code>-D</code> 列出文件或目录的更改时间。</li></ul><p>​    </p><h3 id="实例-默认显示"><a href="#实例-默认显示" class="headerlink" title="实例 默认显示"></a>实例 默认显示</h3><p>默认显示当前目录的信息，比如tree和tree .的含义一样。命令有如下输出结果：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$ tree   </span><br><span class="line">.</span><br><span class="line">├── a</span><br><span class="line">├── aa</span><br><span class="line">│   ├── aab</span><br><span class="line">│   ├── aac</span><br><span class="line">│   ├── aad</span><br><span class="line">│   └── aae</span><br><span class="line">├── b</span><br><span class="line">├── bb</span><br><span class="line">│   └── bbb</span><br><span class="line">├── c</span><br><span class="line">├── d</span><br><span class="line">├── e</span><br><span class="line">└── f</span><br><span class="line"></span><br><span class="line">2 directories, 11 files</span><br></pre></td></tr></tbody></table></figure><h3 id="只显示目录"><a href="#只显示目录" class="headerlink" title="只显示目录"></a>只显示目录</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ tree -d         </span><br><span class="line">.</span><br><span class="line">├── aa</span><br><span class="line">└── bb</span><br></pre></td></tr></tbody></table></figure><h3 id="显示具体的修改时间"><a href="#显示具体的修改时间" class="headerlink" title="显示具体的修改时间"></a>显示具体的修改时间</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$ tree -D</span><br><span class="line">.</span><br><span class="line">├── [Apr 7 22:34]  a</span><br><span class="line">├── [Apr 7 22:37]  aa</span><br><span class="line">│   ├── [Apr 7 22:35]  aab</span><br><span class="line">│   ├── [Apr 7 22:35]  aac</span><br><span class="line">│   ├── [Apr 7 22:35]  aad</span><br><span class="line">│   └── [Apr 7 22:35]  aae</span><br><span class="line">├── [Apr 7 22:34]  b</span><br><span class="line">├── [Apr 7 22:39]  bb</span><br><span class="line">│   └── [Apr 7 22:39]  bbb</span><br><span class="line">├── [Apr 7 22:34]  c</span><br><span class="line">├── [Apr 7 22:34]  d</span><br><span class="line">├── [Apr 7 22:33]  e</span><br><span class="line">└── [Apr 7 22:33]  f</span><br><span class="line"></span><br><span class="line">2 directories, 11 files</span><br></pre></td></tr></tbody></table></figure><blockquote><p>默认情况下tree可能没有安装，可以通过<code>apt</code>/<code>yum</code> install tree来安装。</p></blockquote><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Linux中最常用的目录导航命令&quot;&gt;&lt;a href=&quot;#Linux中最常用的目录导航命令&quot; class=&quot;headerlink&quot; title=&quot;Linux中最常用的目录导航命令&quot;&gt;&lt;/a&gt;Linux中最常用的目录导航命令&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt; </summary>
      
    
    
    
    <category term="Linux集锦" scheme="http://shaoguangleo.github.io/categories/Linux%E9%9B%86%E9%94%A6/"/>
    
    
    <category term="cd" scheme="http://shaoguangleo.github.io/tags/cd/"/>
    
    <category term="pwd" scheme="http://shaoguangleo.github.io/tags/pwd/"/>
    
    <category term="ls" scheme="http://shaoguangleo.github.io/tags/ls/"/>
    
    <category term="dir" scheme="http://shaoguangleo.github.io/tags/dir/"/>
    
    <category term="tree" scheme="http://shaoguangleo.github.io/tags/tree/"/>
    
  </entry>
  
  <entry>
    <title>linux中最常用的文件操作命令</title>
    <link href="http://shaoguangleo.github.io/2023/12/17/linux-collection-file-operation/"/>
    <id>http://shaoguangleo.github.io/2023/12/17/linux-collection-file-operation/</id>
    <published>2023-12-17T14:28:00.000Z</published>
    <updated>2025-06-19T13:19:18.872Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux中最常用的文件操作命令"><a href="#Linux中最常用的文件操作命令" class="headerlink" title="Linux中最常用的文件操作命令"></a>Linux中最常用的文件操作命令</h1><blockquote><p> 仅个人想法，会持续不间断更新和改进。</p></blockquote><p>在Linux的庞大世界中，搜索犹如明灯，可以拨开云雾见青天，照亮我们前行大道路。</p><p>无论你是在浩瀚的代码库中搜索一个特定的函数，还是在庞大的文件系统中寻找一个文件，搜索命令着实是不可或缺尤为重要的工具。</p><p>而其中最绕不开的当属以下几个。</p><hr><h2 id="一切皆可查的-find"><a href="#一切皆可查的-find" class="headerlink" title="一切皆可查的 find"></a>一切皆可查的 find</h2><p><code>find</code>命令用来在指定目录下查找文件，功能相当之强大。</p><p>官方定义为：</p><blockquote><p>find - search for files in a directory hierarchy</p></blockquote><p>Linux的哲学是<strong>一切皆文件</strong>，那么find的使命就是<strong>一切皆可查</strong>。</p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p>使用语法为：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ find [-H] [-L] [-P] [-D debugopts] [-Olevel] [path...] [expression]</span><br></pre></td></tr></tbody></table></figure><p>比较常用的几个参数为：</p><ul><li><code>-exec &lt;执行指令&gt;</code>：假设find指令的回传值为True，就执行该指令；</li><li><code>-size &lt;文件大小&gt;</code>：查找符合指定的文件大小的文件；</li><li><code>-mtime &lt;24小时&gt;</code>：查找在指定时间曾被更改过的文件或目录，单位以24小时计算；<br>-name&lt;范本样式&gt;：指定字符串作为寻找文件或目录的范本样式；</li><li><code>-type &lt;文件类型&gt;</code>：只寻找符合指定的文件类型的文件；</li></ul><h3 id="无参数"><a href="#无参数" class="headerlink" title="无参数"></a>无参数</h3><p>如果使用该命令时，不设置任何参数，则<code>find</code>命令将在当前目录下查找子目录与文件,并且将查找到的子目录和文件全部进行显示。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">ls</span> -l</span><br><span class="line">total 310M</span><br><span class="line">-rw-rw-r-- 1 user user  10M Mar 21 20:01 a</span><br><span class="line">drwxrwxr-x 2 user user   22 Mar 21 20:01 aa</span><br><span class="line">-rw-rw-r-- 1 user user 100M Mar 21 20:01 b</span><br><span class="line">-rw-rw-r-- 1 user user 200M Mar 21 20:01 c</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$ find </span><br><span class="line">.</span><br><span class="line">./a</span><br><span class="line">./b</span><br><span class="line">./c</span><br><span class="line">./test</span><br></pre></td></tr></tbody></table></figure><h3 id="查找小于，等于和大于100MB的文件"><a href="#查找小于，等于和大于100MB的文件" class="headerlink" title="查找小于，等于和大于100MB的文件"></a>查找小于，等于和大于100MB的文件</h3><p>通过-size大小来查找文件</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ find . -size -100M</span><br><span class="line">.</span><br><span class="line">./a</span><br><span class="line">./aa</span><br><span class="line">$ find . -size 100M</span><br><span class="line">./b</span><br><span class="line">$ find . -size +100M</span><br><span class="line">./c</span><br><span class="line">./aa/d</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h3 id="查找多长时间修改过"><a href="#查找多长时间修改过" class="headerlink" title="查找多长时间修改过"></a>查找多长时间修改过</h3><p>可以通过参数-mtime来查找文件的修改时间，比如如下可以查找当前目录下最近60天没有被修改的文件。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ find . -mtime +60</span><br><span class="line"></span><br><span class="line"><span class="comment"># 最近2天以内未修改</span></span><br><span class="line">$ find . –mtime -2</span><br></pre></td></tr></tbody></table></figure><h3 id="稍微复杂但是很有用的命令"><a href="#稍微复杂但是很有用的命令" class="headerlink" title="稍微复杂但是很有用的命令"></a>稍微复杂但是很有用的命令</h3><p> 我经常把 <code>find</code> 命令和他的选项 <code>exec</code>一起使用，比如我想查找一个目录中的所有文件并将其更改其权限。可以通过以下简单命令完成：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ find /path/ -<span class="built_in">type</span> f -<span class="built_in">exec</span> <span class="built_in">chmod</span> 644 {} \;</span><br></pre></td></tr></tbody></table></figure><p>这个命令会递归搜索指定目录内<u>/path/</u>下的所有文件，并对找到的文件执行 <code>chmod</code> 命令。</p><h2 id="精准快速定位的locate"><a href="#精准快速定位的locate" class="headerlink" title="精准快速定位的locate"></a>精准快速定位的locate</h2><p>.. note::</p><p>  众里寻他千百度，蓦然回首，那人却在灯火阑珊处<br>  -李煜</p><p>Linux <code>locate</code>命令用于查找符合条件的文档、程序、目录等等。这个命令会在数据库中查找符合条件的各种信息。</p><p>一般情况我们只需要输入 <code>locate name</code> 即可查找。</p><p>官方定义为：</p><blockquote><p><code>locate</code> - list files in databases that match a pattern</p></blockquote><p>使用方法为：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ locate  [-d  path  |  --database=path]  [-e  | -E | --[non-]existing] [-i | --ignore-case] [-0 | --null] [-c |</span><br><span class="line">       --count] [-w | --wholename] [-b | --<span class="built_in">basename</span>] [-l N | --<span class="built_in">limit</span>=N] [-S | --statistics] [-r | --regex ] [--regex‐</span><br><span class="line">       <span class="built_in">type</span>  R] [--max-database-age D] [-P | -H | --nofollow] [-L | --follow] [--version] [-A | --all] [-p | --<span class="built_in">print</span>]</span><br><span class="line">       [--<span class="built_in">help</span>] pattern...</span><br></pre></td></tr></tbody></table></figure><p>看着很复杂，不过常用的参数倒是不多，基本为：</p><ul><li><code>-n</code> :  至多显示 n个输出。</li><li><code>-i, --ignore-case</code> : 忽略大小写</li></ul><h3 id="默认无参数"><a href="#默认无参数" class="headerlink" title="默认无参数"></a>默认无参数</h3><p>默认情况下，<code>locate</code>直接跟上需要查找的信息就可以了，如下所示：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">$ locate set_vis.cpp</span><br><span class="line">/home/user/mycode/src/set_vis.cpp</span><br><span class="line"></span><br><span class="line"><span class="comment"># 以查找apropos为例</span></span><br><span class="line">$ locate apropos</span><br><span class="line">/usr/bin/apropos</span><br><span class="line">/usr/local/difmap/help/apropos.hlp</span><br><span class="line">/usr/share/emacs/24.3/lisp/apropos.elc</span><br><span class="line">/usr/share/man/de/man1/apropos.1.gz</span><br><span class="line">/usr/share/man/es/man1/apropos.1.gz</span><br><span class="line">/usr/share/man/fr/man1/apropos.1.gz</span><br><span class="line">/usr/share/man/id/man1/apropos.1.gz</span><br><span class="line">/usr/share/man/it/man1/apropos.1.gz</span><br><span class="line">/usr/share/man/ja/man1/apropos.1.gz</span><br><span class="line">/usr/share/man/man1/apropos.1.gz</span><br><span class="line">/usr/share/man/nl/man1/apropos.1.gz</span><br><span class="line">/usr/share/man/pl/man1/apropos.1.gz</span><br><span class="line">/usr/share/man/ru/man1/apropos.1.gz</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h3 id="太多需要简单化"><a href="#太多需要简单化" class="headerlink" title="太多需要简单化"></a>太多需要简单化</h3><p>如果输出的信息很多，仅仅希望看到前面的几个，使用<code>-n</code>参数既可</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 仅仅查看前的3个</span></span><br><span class="line">$ locate -n 3 apropos</span><br><span class="line">/usr/bin/apropos</span><br><span class="line">/usr/local/difmap/help/apropos.hlp</span><br><span class="line">/usr/share/emacs/24.3/lisp/apropos.elc</span><br></pre></td></tr></tbody></table></figure><h3 id="不区分大小写"><a href="#不区分大小写" class="headerlink" title="不区分大小写"></a>不区分大小写</h3><p>部分情况下，可能有大小写混淆的情况，此时使用<code>-i</code>参数既可</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ $ locate -i set_vis.cpp</span><br><span class="line">/home/user/mycode/src/set_vis.cpp</span><br><span class="line">/home/user/mycode_CPP/src/set_VIS.cpp</span><br></pre></td></tr></tbody></table></figure><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><p>不过刚按照的系统，这个命令并不一定有输出，主要是因为<code>locate</code> 与 <code>find</code> 不同， <code> find</code> 直接在硬盘找，而<code>locate</code> 只在数据库中查找。</p><p>这个数据库在CentOS系统默认的为 <u>/var/lib/mlocate/mlocate.db</u> 中，所以<code> locate</code> 的查找会比较快，但并一定是实时的，而是以数据库的更新为准。</p><p>可以通过下面的命令手工升级数据库 ，命令为：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ updatedb</span><br></pre></td></tr></tbody></table></figure><p>然后就可以使用了。</p><h2 id="文件内容搜索利器-grep"><a href="#文件内容搜索利器-grep" class="headerlink" title="文件内容搜索利器 - grep"></a>文件内容搜索利器 - grep</h2><p>Linux <code>grep</code> 命令用于查找文件里符合条件的字符串。</p><p>官方定义为：</p><blockquote><p><code>grep</code>, <code>egrep</code>, <code>fgrep</code> - print lines matching a pattern</p></blockquote><p>grep支持正则表达式，是一个强大的文本搜索工具。</p><h3 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h3><p>语法也挺复杂，因为功能确实很强大。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ grep [OPTION...] PATTERNS [FILE...]</span><br><span class="line">$ grep [OPTION...] -e PATTERNS ... [FILE...]      <span class="comment"># 使用egrep</span></span><br><span class="line">$ grep [OPTION...] -f PATTERN_FILE ... [FILE...]  <span class="comment"># 使用fgrep</span></span><br></pre></td></tr></tbody></table></figure><p>常用的参数为：</p><ul><li><strong>-r 或 –recursive</strong> : 此参数的效果和指定”-d recurse”参数相同</li><li><strong>-v 或 –invert-match</strong> : 显示不包含匹配文本的所有行</li><li><strong>-i 或 –ignore-case</strong> : 忽略字符大小写的差别</li><li><strong>-n 或 –line-number</strong> : 在显示符合样式的那一行之前，标示出该行的列数编号。</li></ul><p>假定有如下3个文件，1个文件夹，内容如下：</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">a</span></span><br><span class="line">    This is <span class="selector-tag">a</span></span><br><span class="line">    Hello <span class="selector-tag">a</span></span><br><span class="line">    </span><br><span class="line"><span class="selector-tag">b</span> </span><br><span class="line">    this is <span class="selector-tag">b</span></span><br><span class="line">    Hello <span class="selector-tag">b</span></span><br><span class="line">c </span><br><span class="line">    This is c</span><br><span class="line">    Hello c</span><br><span class="line"></span><br><span class="line">d/d </span><br><span class="line">    This is d</span><br><span class="line">    Hello d</span><br></pre></td></tr></tbody></table></figure><h3 id="默认无参数-1"><a href="#默认无参数-1" class="headerlink" title="默认无参数"></a>默认无参数</h3><p>在当前目录搜索包含<strong>is</strong>字符串，可以看到**<u>a/b/c</u>**三个文件均有输出，而<u>d</u>因为是目录，暂时无输出。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ grep is *</span><br><span class="line">a:This is a</span><br><span class="line">b:this is b</span><br><span class="line">c:This is c</span><br><span class="line">grep: d: Is a directory</span><br></pre></td></tr></tbody></table></figure><h3 id="增加文件夹"><a href="#增加文件夹" class="headerlink" title="增加文件夹"></a>增加文件夹</h3><p>与其他命令类似，增加<code>-r</code>参数，递归搜索</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ grep -r is *</span><br><span class="line">a:This is a</span><br><span class="line">b:this is b</span><br><span class="line">c:This is c</span><br><span class="line">d/d:This is d</span><br></pre></td></tr></tbody></table></figure><h3 id="反向查找"><a href="#反向查找" class="headerlink" title="反向查找"></a>反向查找</h3><p>在某些情况下，或许正想找到不包含某些字符串的内容，如下：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ grep -rv is *</span><br><span class="line">a:Hello a</span><br><span class="line">b:Hello b</span><br><span class="line">c:Hello c</span><br><span class="line">d/d:Hello d</span><br></pre></td></tr></tbody></table></figure><p>此时可以看到，不包含<strong>is</strong>的内容显示了出来。</p><h3 id="不区分大小写-1"><a href="#不区分大小写-1" class="headerlink" title="不区分大小写"></a>不区分大小写</h3><p>而某些情况下，或许我们希望找到不区分大小写的内容，比如对于<u>This/this</u>而言：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ grep -r This *</span><br><span class="line">a:This is a</span><br><span class="line">c:This is c</span><br><span class="line">d/d:This is d</span><br><span class="line"></span><br><span class="line">$ grep -ri This *</span><br><span class="line">a:This is a</span><br><span class="line">b:this is b</span><br><span class="line">c:This is c</span><br><span class="line">d/d:This is d</span><br></pre></td></tr></tbody></table></figure><p>可以看到此时有可能笔误，或者其他原因的b文件已经被找到了。</p><h3 id="显示行数，精准定位"><a href="#显示行数，精准定位" class="headerlink" title="显示行数，精准定位"></a>显示行数，精准定位</h3><p>   如果文件内容比较多，此时显示内容在哪一行，是很重要的，加上<code>-n</code>参数既可解决。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ grep -rn This *</span><br><span class="line">a:1:This is a</span><br><span class="line">c:1:This is c</span><br><span class="line">d/d:1:This is d</span><br></pre></td></tr></tbody></table></figure><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Linux中最常用的文件操作命令&quot;&gt;&lt;a href=&quot;#Linux中最常用的文件操作命令&quot; class=&quot;headerlink&quot; title=&quot;Linux中最常用的文件操作命令&quot;&gt;&lt;/a&gt;Linux中最常用的文件操作命令&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt; </summary>
      
    
    
    
    <category term="Linux集锦" scheme="http://shaoguangleo.github.io/categories/Linux%E9%9B%86%E9%94%A6/"/>
    
    
    <category term="search" scheme="http://shaoguangleo.github.io/tags/search/"/>
    
    <category term="diff" scheme="http://shaoguangleo.github.io/tags/diff/"/>
    
    <category term="cat" scheme="http://shaoguangleo.github.io/tags/cat/"/>
    
    <category term="文件操作" scheme="http://shaoguangleo.github.io/tags/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/"/>
    
    <category term="uniq" scheme="http://shaoguangleo.github.io/tags/uniq/"/>
    
    <category term="tac" scheme="http://shaoguangleo.github.io/tags/tac/"/>
    
    <category term="tail" scheme="http://shaoguangleo.github.io/tags/tail/"/>
    
    <category term="head" scheme="http://shaoguangleo.github.io/tags/head/"/>
    
    <category term="find" scheme="http://shaoguangleo.github.io/tags/find/"/>
    
    <category term="locate" scheme="http://shaoguangleo.github.io/tags/locate/"/>
    
  </entry>
  
  <entry>
    <title>linux中最常用的帮助命令</title>
    <link href="http://shaoguangleo.github.io/2023/12/12/linux-collection-help-commands/"/>
    <id>http://shaoguangleo.github.io/2023/12/12/linux-collection-help-commands/</id>
    <published>2023-12-12T14:28:00.000Z</published>
    <updated>2025-06-19T13:19:18.872Z</updated>
    
    <content type="html"><![CDATA[<h1 id="linux中最常用的帮助命令"><a href="#linux中最常用的帮助命令" class="headerlink" title="linux中最常用的帮助命令"></a>linux中最常用的帮助命令</h1><blockquote><p>仅个人想法，会持续不间断更新和改进。</p></blockquote><p>Linux有好几个关于帮助的命令，可以让我们在不上网的情况下获取一些丰硕的信息。</p><p>唯一的要求就是英语好一些，唯二的情况就是不确定的情况下在此确认后再执行。</p><hr><h2 id="此man非man的意思"><a href="#此man非man的意思" class="headerlink" title="此man非man的意思"></a>此man非man的意思</h2><blockquote><p>首先，这man是什么意思？</p><p>最开始很多人认为是不知道这个什么意思，找man呀。</p><p>其实man是manual的缩写，也就是手册的意思。</p></blockquote><p><code>man</code>命令提供了系统命令的详细帮助信息。</p><p><strong>Linux</strong>提供了丰富的帮助手册，当你需要查看某个命令的参数时不必到处上网查找，只要<code>man</code>一下即可。这个也是每个程序员必备的功能，在没有网络的情况下，<code>man</code>能解决很多问题和疑惑。</p><p>看一下官方定义：</p><blockquote><p>Man - format and display the on-line manual pages</p></blockquote><h3 id="man-的格式"><a href="#man-的格式" class="headerlink" title="man 的格式"></a>man 的格式</h3><p>如果要读懂并使用<code>man</code>，首先需要了解<code>man</code>命令输出的格式，下面的几个是比较常用且需要注意的：</p><blockquote><p>同时也可以使用man man 查看man的使用方法。</p></blockquote><table><thead><tr><th align="left">章节</th><th align="left">含义</th></tr></thead><tbody><tr><td align="left"><strong>NAME</strong></td><td align="left">命令名称及功能简要说明</td></tr><tr><td align="left"><strong>SYNOPSIS</strong></td><td align="left">用法说明，包括可用的选项</td></tr><tr><td align="left"><strong>DESCRIPTION</strong></td><td align="left">命令功能的详细说明，可能包括每一个选项的意义</td></tr><tr><td align="left"><strong>OPTIONS</strong></td><td align="left">每一选项的意义</td></tr><tr><td align="left"><strong>EXAMPLES</strong></td><td align="left">一些使用示例</td></tr></tbody></table><h3 id="man的操作"><a href="#man的操作" class="headerlink" title="man的操作"></a>man的操作</h3><p>  比如输入<code>man ls</code>  后，跳出下面的内容：</p><figure class="highlight livecodeserver"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">LS(<span class="number">1</span>)                                               User Commands                                              LS(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">NAME</span><br><span class="line">       ls - list <span class="built_in">directory</span> contents</span><br><span class="line"></span><br><span class="line">SYNOPSIS</span><br><span class="line">       ls [OPTION]... [FILE]...</span><br><span class="line"></span><br><span class="line">DESCRIPTION</span><br><span class="line">       List  information about <span class="keyword">the</span> FILEs (<span class="keyword">the</span> current <span class="built_in">directory</span> <span class="keyword">by</span> default).  Sort entries alphabetically <span class="keyword">if</span> <span class="literal">none</span> <span class="keyword">of</span></span><br><span class="line">       -cftuvSUX nor <span class="comment">--sort is specified.</span></span><br><span class="line"></span><br><span class="line">       Mandatory arguments <span class="built_in">to</span> <span class="keyword">long</span> options are mandatory <span class="keyword">for</span> <span class="keyword">short</span> options too.</span><br><span class="line"></span><br><span class="line">       -<span class="keyword">a</span>, <span class="comment">--all</span></span><br><span class="line">              <span class="built_in">do</span> <span class="keyword">not</span> ignore entries starting <span class="keyword">with</span> .</span><br><span class="line"></span><br><span class="line">       -A, <span class="comment">--almost-all</span></span><br><span class="line">              <span class="built_in">do</span> <span class="keyword">not</span> list implied . <span class="keyword">and</span> ..</span><br><span class="line"></span><br><span class="line">       <span class="comment">--author</span></span><br><span class="line">              <span class="keyword">with</span> -l, print <span class="keyword">the</span> author <span class="keyword">of</span> <span class="keyword">each</span> <span class="built_in">file</span></span><br><span class="line"></span><br><span class="line">       -b, <span class="comment">--escape</span></span><br><span class="line">              print C-style escapes <span class="keyword">for</span> nongraphic <span class="keyword">characters</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">--block-size=SIZE</span></span><br><span class="line">              scale sizes <span class="keyword">by</span> SIZE <span class="keyword">before</span> printing them; e.g., <span class="string">'--block-size=M'</span> prints sizes <span class="keyword">in</span>  units  <span class="keyword">of</span>  <span class="number">1</span>,<span class="number">048</span>,<span class="number">576</span></span><br><span class="line">              <span class="keyword">bytes</span>; see SIZE <span class="built_in">format</span> below</span><br><span class="line"></span><br><span class="line">       -B, <span class="comment">--ignore-backups</span></span><br><span class="line"> Manual page ls(<span class="number">1</span>) <span class="built_in">line</span> <span class="number">1</span> (press h <span class="keyword">for</span> help <span class="keyword">or</span> q <span class="built_in">to</span> quit)</span><br></pre></td></tr></tbody></table></figure><p>此时可以通过空格键或者回车键来向后翻屏或者翻页，可以使用<strong>b</strong>或者<strong>k</strong>向前查看。</p><p>　查看关键词时可以使用：</p><p>  <code>/关键词</code>    向后查找   <code>n</code>：下一个</p><p>  <code>?关键词</code>   向前查找   <code>N</code>：前一个</p><p>可以通过<code>q</code>来退出。</p><blockquote><p>ls后面还有一个（1）,详细的解释可以参考《Linux 安装 man 帮助程序》</p></blockquote><h3 id="类似于whatis命令"><a href="#类似于whatis命令" class="headerlink" title="类似于whatis命令"></a>类似于whatis命令</h3><p><code>man</code>有个参数为<code>-f</code>，就是<code>whatis</code>的功能，比如：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ man -f <span class="built_in">ls</span> <span class="built_in">cd</span> file <span class="built_in">cat</span> more less</span><br><span class="line"><span class="built_in">ls</span> (1)               - list directory contents</span><br><span class="line"><span class="built_in">ls</span> (1p)              - list directory contents</span><br><span class="line"><span class="built_in">cd</span> (1)               - bash built-in commands, see bash(1)</span><br><span class="line"><span class="built_in">cd</span> (1p)              - change the working directory</span><br><span class="line"><span class="built_in">cd</span> (n)               - Change working directory</span><br><span class="line">file (1)             - determine file <span class="built_in">type</span></span><br><span class="line">file (1p)            - determine file <span class="built_in">type</span></span><br><span class="line">file (n)             - Manipulate file names and attributes</span><br><span class="line"><span class="built_in">cat</span> (1)              - concatenate files and <span class="built_in">print</span> on the standard output</span><br><span class="line"><span class="built_in">cat</span> (1p)             - concatenate and <span class="built_in">print</span> files</span><br><span class="line">more (1)             - file perusal filter <span class="keyword">for</span> crt viewing</span><br><span class="line">more (1p)            - display files on a page-by-page basis</span><br><span class="line">less (1)             - opposite of more</span><br><span class="line">less (3pm)           - perl pragma to request less of something</span><br></pre></td></tr></tbody></table></figure><blockquote><p>与whatis命令完全一致</p></blockquote><h3 id="类似于apropos命令"><a href="#类似于apropos命令" class="headerlink" title="类似于apropos命令"></a>类似于apropos命令</h3><p><code>man</code>有个参数为<code>-k</code>，就是<code>apropos</code>的功能，比如：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ man -k  <span class="built_in">who</span></span><br><span class="line">at.allow (5)         - determine <span class="built_in">who</span> can submit <span class="built_in">jobs</span> via at or batch</span><br><span class="line">at.deny (5)          - determine <span class="built_in">who</span> can submit <span class="built_in">jobs</span> via at or batch</span><br><span class="line">btrfs-filesystem (8) - <span class="built_in">command</span> group of btrfs that usually work on the whole filesystem</span><br><span class="line">docker-trust-signer (1) - Manage entities <span class="built_in">who</span> can sign Docker images</span><br><span class="line">ipsec_newhostkey (8) - generate a new raw RSA authentication key <span class="keyword">for</span> a host</span><br><span class="line">ipsec_showhostkey (8) - show host<span class="string">'s authentication key</span></span><br><span class="line"><span class="string">w (1)                - Show who is logged on and what they are doing.</span></span><br><span class="line"><span class="string">who (1)              - show who is logged on</span></span><br><span class="line"><span class="string">who (1p)             - display who is on the system</span></span><br><span class="line"><span class="string">whoami (1)           - print effective userid</span></span><br></pre></td></tr></tbody></table></figure><blockquote><p>与apropos命令完全一致</p></blockquote><h3 id="使用man的小技巧"><a href="#使用man的小技巧" class="headerlink" title="使用man的小技巧"></a>使用man的小技巧</h3><p> 如果遇到一个不熟悉或者完全不知道的命令，此时可以通过下面的3个步骤来了解：</p><ol><li>首先用<code>man -k command</code> 查询所有类似帮助文件信息，或许有可能就能找到你需要的信息；</li><li>然后<code>man -f command</code> 查询以<code>command</code>开始的相关帮助信息列表</li><li><code>man  N command</code> 通过直接定位N获得详细帮助信息</li></ol><h2 id="你是干什么的-whatis"><a href="#你是干什么的-whatis" class="headerlink" title="你是干什么的 whatis"></a>你是干什么的 whatis</h2><p>其实整个命令已出现，你的脑海里面应该浮现的是：</p><blockquote><p>What is your name?</p></blockquote><p>如题所述，<u>这个命令用于查询一个命令到底执行了什么功能，并将查询的结果输出出来，</u>相当于<code>man</code>的一个选项<code>-f</code>。</p><p><code>whatis</code>的官方定义为：</p><blockquote><p>whatis - display manual page descriptions</p></blockquote><p>仅仅提供一个比较简单的命令描述.</p><p>使用方法也比较简单，如下：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ whatis [options] name</span><br></pre></td></tr></tbody></table></figure><blockquote><p>其中的name可以是Linux命令、系统调用、库函数、系统等等内容</p></blockquote><p>以前面的命令为例，执行如下所示：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ whatis <span class="built_in">ls</span> <span class="built_in">cd</span> file <span class="built_in">cat</span> more less</span><br><span class="line"><span class="built_in">ls</span> (1)               - list directory contents</span><br><span class="line"><span class="built_in">ls</span> (1p)              - list directory contents</span><br><span class="line"><span class="built_in">cd</span> (1)               - bash built-in commands, see bash(1)</span><br><span class="line"><span class="built_in">cd</span> (1p)              - change the working directory</span><br><span class="line"><span class="built_in">cd</span> (n)               - Change working directory</span><br><span class="line">file (1)             - determine file <span class="built_in">type</span></span><br><span class="line">file (1p)            - determine file <span class="built_in">type</span></span><br><span class="line">file (n)             - Manipulate file names and attributes</span><br><span class="line"><span class="built_in">cat</span> (1)              - concatenate files and <span class="built_in">print</span> on the standard output</span><br><span class="line"><span class="built_in">cat</span> (1p)             - concatenate and <span class="built_in">print</span> files</span><br><span class="line">more (1)             - file perusal filter <span class="keyword">for</span> crt viewing</span><br><span class="line">more (1p)            - display files on a page-by-page basis</span><br><span class="line">less (1)             - opposite of more</span><br><span class="line">less (3pm)           - perl pragma to request less of something</span><br></pre></td></tr></tbody></table></figure><blockquote><p>可以看到whatis是支持同时查询多个命令的</p></blockquote><h3 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h3><p><code>whatis</code>可以通过<code>-w</code>、<code>-r</code>以及<code>-C</code>等选项来设定通配符、正则表达式以及配置文件等等，不过最简单的还是简单查看一个命令的简单描述，其他的可以交给<code>man</code>来处理。</p><h2 id="指定目录的定位-whereis"><a href="#指定目录的定位-whereis" class="headerlink" title="指定目录的定位 whereis"></a>指定目录的定位 whereis</h2><p>Linux <code>whereis</code> 命令用于定位查找一个命令的二进制、源文件或帮助文件。</p><p>不过这些文件一般是位于特定目录的。</p><p>其他的程序定位可以考虑使用<code>locate</code>命令。</p><p>官方的定义为：</p><blockquote><p>whereis - locate the binary, source, and manual page files for a command</p></blockquote><h3 id="使用语法"><a href="#使用语法" class="headerlink" title="使用语法"></a>使用语法</h3><p>使用语法如下：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ whereis [options] [-BMS directory... -f] name...</span><br></pre></td></tr></tbody></table></figure><p>其他的选项可以为： </p><ul><li><p><code>-b</code> : 查找二进制文件</p></li><li><p><code>-m</code>：查找手册</p></li><li><p><code>-s</code>：查找源文件</p></li><li><p><code>-B &lt;directory&gt;</code> 　在设置的目录下查找二进制文件。</p></li><li><p><code>-M &lt;directory&gt;</code> 　在设置的目录下查找说明文件。</p></li><li><p><code>-S &lt;directory&gt;</code> 　在设置的目录下查找原始代码文件。</p></li></ul><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>比如查找<code>bash</code>的位置，输入如下命令：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ whereis bash</span><br><span class="line">bash: /usr/bin/bash /etc/bash.bashrc /usr/share/man/man1/bash.1.gz</span><br></pre></td></tr></tbody></table></figure><p>可以看到，以上的输出信息从左至右分别为程序名、bash路径、bash的man帮助手册路径。</p><h3 id="单独查找文件"><a href="#单独查找文件" class="headerlink" title="单独查找文件"></a>单独查找文件</h3><p>可以通过不同的参数来查找不同的文件，如下：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查找二进制文件</span></span><br><span class="line">$ whereis -b bash</span><br><span class="line">bash: /usr/bin/bash /etc/bash.bashrc </span><br><span class="line"></span><br><span class="line"><span class="comment"># 查找帮助文件</span></span><br><span class="line">$ whereis -m bash</span><br><span class="line">bash: /usr/share/man/man1/bash.1.gz</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查找源文件</span></span><br><span class="line">$ whereis -s bash</span><br><span class="line">bash:</span><br></pre></td></tr></tbody></table></figure><h2 id="刚刚好合适的-apropos-命令"><a href="#刚刚好合适的-apropos-命令" class="headerlink" title="刚刚好合适的 apropos 命令"></a>刚刚好合适的 apropos 命令</h2><p><code>apropos</code>的中文含义就是<u>恰好的、合适的</u>，奈何这个单词或者命令确实不好记，当然是可以扩充词汇量的。</p><p>什么时候会用到这个命令呢，先看看这个命令的定义。</p><p><code>apropos</code> 命令的官方定义为:</p><blockquote><p> search the manual page names and descriptions</p></blockquote><p>意思很明显，如果我不记得命令或者不知道该用什么命令的时候，可以通过关键词来索引查找这些命令，比如我们想用linux绘制图像，但是不知道什么命令，测试可以使用：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ apropos plot</span><br><span class="line"></span><br><span class="line">bno_plot (1) – generate interactive 3D plot of IO blocks and sizes </span><br><span class="line">gnuplot (1) – an interactive plotting program </span><br><span class="line">pbmtoplot (1) – convert a PBM image into a Unix <span class="string">'plot'</span> file</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><blockquote><p>或许每个人的输出不同，这个主要取决于安装的软件包和索引的数据库。以上。</p></blockquote><p>再来一个实例，这个应该大部分的都类似：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ apropos <span class="built_in">who</span></span><br><span class="line"></span><br><span class="line">at.allow (5)         - determine <span class="built_in">who</span> can submit <span class="built_in">jobs</span> via at or batch</span><br><span class="line">at.deny (5)          - determine <span class="built_in">who</span> can submit <span class="built_in">jobs</span> via at or batch</span><br><span class="line">btrfs-filesystem (8) - <span class="built_in">command</span> group of btrfs that usually work on the whole filesystem</span><br><span class="line">docker-trust-signer (1) - Manage entities <span class="built_in">who</span> can sign Docker images</span><br><span class="line">ipsec_newhostkey (8) - generate a new raw RSA authentication key <span class="keyword">for</span> a host</span><br><span class="line">ipsec_showhostkey (8) - show host<span class="string">'s authentication key</span></span><br><span class="line"><span class="string">w (1)                - Show who is logged on and what they are doing.</span></span><br><span class="line"><span class="string">who (1)              - show who is logged on</span></span><br><span class="line"><span class="string">who (1p)             - display who is on the system</span></span><br><span class="line"><span class="string">whoami (1)           - print effective userid</span></span><br></pre></td></tr></tbody></table></figure><blockquote><p> 这个命令平时用的不多，跟whatis类似，因为这些功能都被加到了包罗万象的man命令。</p></blockquote><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;linux中最常用的帮助命令&quot;&gt;&lt;a href=&quot;#linux中最常用的帮助命令&quot; class=&quot;headerlink&quot; title=&quot;linux中最常用的帮助命令&quot;&gt;&lt;/a&gt;linux中最常用的帮助命令&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;仅个人想法，会持续</summary>
      
    
    
    
    <category term="Linux集锦" scheme="http://shaoguangleo.github.io/categories/Linux%E9%9B%86%E9%94%A6/"/>
    
    
    <category term="linux" scheme="http://shaoguangleo.github.io/tags/linux/"/>
    
    <category term="apropos" scheme="http://shaoguangleo.github.io/tags/apropos/"/>
    
    <category term="man" scheme="http://shaoguangleo.github.io/tags/man/"/>
    
    <category term="whatis" scheme="http://shaoguangleo.github.io/tags/whatis/"/>
    
    <category term="whereis" scheme="http://shaoguangleo.github.io/tags/whereis/"/>
    
  </entry>
  
  <entry>
    <title>Linux最有趣的几个命令</title>
    <link href="http://shaoguangleo.github.io/2023/12/06/linux-collection-funny-commands/"/>
    <id>http://shaoguangleo.github.io/2023/12/06/linux-collection-funny-commands/</id>
    <published>2023-12-06T14:28:00.000Z</published>
    <updated>2025-06-19T13:19:18.872Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux最有趣的几个命令"><a href="#Linux最有趣的几个命令" class="headerlink" title="Linux最有趣的几个命令"></a>Linux最有趣的几个命令</h1><blockquote><p>仅个人想法，会持续不间断更新和改进。</p></blockquote><p>这次介绍一些好玩有趣的命令，不过说实话，实用性倒不是很大，纯粹好玩，给单调的命令行界面增加了一些童趣和欢乐。</p><hr><h2 id="命运的小火车sl"><a href="#命运的小火车sl" class="headerlink" title="命运的小火车sl"></a>命运的小火车sl</h2><p>发现这个命令是在输入<code>ls</code>命令的时候，一不小心敲反了，直接命运的小火车开始跑了起来。</p><p><code>sl</code> 是一个 “Steam Locomotive” 的缩写，它会显示一个老式的蒸汽火车在终端中穿梭。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">$ sl</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  (  ) (@@) ( )  (@)  ()    @@    O     @     O     @      O</span><br><span class="line">@)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">______                ___________</span><br><span class="line">      \__I_I_____===__|_________|</span><br><span class="line">______/ |   |        =|___ ___|      _________________</span><br><span class="line">  |     |   |         ||_| |_||     _|                \_____A</span><br><span class="line">__--------------------| [___] |   =|                        |</span><br><span class="line">__|_____/[][]~\_______|       |   -|                        |</span><br><span class="line">-I_____I [][] []  D   |=======|____|________________________|_</span><br><span class="line">=====O=====O\ ____Y___________|__|__________________________|_</span><br><span class="line"> ||    ||    |_____/~\___/          |_D__D__D_|  |_D__D__D_|</span><br><span class="line">/  \__/  \__/      \_/               \_/   \_/    \_/   \_/</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h2 id="点亮终端的艺术之光figlet"><a href="#点亮终端的艺术之光figlet" class="headerlink" title="点亮终端的艺术之光figlet"></a>点亮终端的艺术之光figlet</h2><p>在Linux的世界中，figlet是一个神奇的命令，可以将文字艺术化.</p><p>特别适合作为标题、口号或者问候语，还有很多软件程序的招呼语，也可以用这个来实现。</p><p>比如：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ figlet HELLO          </span><br><span class="line"> _   _ _____ _     _     ___  </span><br><span class="line">| | | | ____| |   | |   / _ \ </span><br><span class="line">| |_| |  _| | |   | |  | | | |</span><br><span class="line">|  _  | |___| |___| |__| |_| |</span><br><span class="line">|_| |_|_____|_____|_____\___/ </span><br><span class="line">                              </span><br></pre></td></tr></tbody></table></figure><h2 id="活灵活现的终端：发掘cowsay"><a href="#活灵活现的终端：发掘cowsay" class="headerlink" title="活灵活现的终端：发掘cowsay"></a>活灵活现的终端：发掘<code>cowsay</code></h2><p><code>cowsay</code>顾名思义就是一头牛为你加持，一款让命令行界面生动有趣的工具。</p><p><code>cowsay</code> 可说话、可思考，与fortune加持更可以变为一头睿智的牛。</p><p>该命令接受一个文本字符串，并输出一个牛说话的图形。</p><p>下面是一头牛在说它喜欢 Linux：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$  cowsay I love linux.</span><br><span class="line"> _______________ </span><br><span class="line">&lt; I love linux. &gt;</span><br><span class="line"> --------------- </span><br><span class="line">        \   ^__^</span><br><span class="line">         \  (oo)\_______</span><br><span class="line">            (__)\       )\/\</span><br><span class="line">                ||----w |</span><br><span class="line">                ||     ||</span><br></pre></td></tr></tbody></table></figure><h2 id="探索Linux世界的智慧——fortunes命令"><a href="#探索Linux世界的智慧——fortunes命令" class="headerlink" title="探索Linux世界的智慧——fortunes命令"></a>探索Linux世界的智慧——fortunes命令</h2><p>在Linux中，有一条神奇的命令连接着智慧与幽默，那就是<code>fortunes</code>命令。</p><p>看似普通的指令，背后却藏匿着千言万语，无论是名人箴言还是妙趣横生的笑话，在这里都能找到它们的踪迹。</p><p>另外最重要的，还可以根据自己的需求进行增删，目前就用基于唐诗宋词的库。</p><p><code>fortune</code>并非只是简单的一句话，而是承载着古今中外智慧的涌泉。</p><p>每次执行，它都会带来截然不同的感受。或许是一位哲人的深刻格言，或是一句调皮的笑话，或者唐诗，或者宋词，与先贤对话，岂不快哉。</p><p>最简单的方法就是把这个命令，加到.bashrc文件中，每次启动，总会有触动。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ fortune </span><br><span class="line">何以称英雄？识以领其先</span><br><span class="line"></span><br><span class="line">　　　　－　清·袁枚</span><br><span class="line">$ fortune</span><br><span class="line">一件作品的固有力量从来不会被长期地埋没或禁锢。一件艺术品可能被时间遗忘，可能遭到查禁，可能被埋进棺材，但威力强大的东西总要战胜没有过大前途的东西。</span><br><span class="line"></span><br><span class="line">　　　　－　茨威格</span><br><span class="line">$ fortune</span><br><span class="line">Yow!  We<span class="string">'re going to a new disco!</span></span><br></pre></td></tr></tbody></table></figure><h2 id="缤纷绚烂的终端体验：探索lolcat"><a href="#缤纷绚烂的终端体验：探索lolcat" class="headerlink" title="缤纷绚烂的终端体验：探索lolcat"></a>缤纷绚烂的终端体验：探索<code>lolcat</code></h2><p><code>lolcat</code>是一款让终端从黑白灰变得缤纷多彩的神奇工具。</p><p>通过将文字渲染成彩虹般的颜色，让你的终端充满欢乐与活力。</p><p>可以把这个命令替换掉cat，这样你的内容都灵动了起来</p><p>比如<code>lolcat /etc/resolv.conf</code>会生成如下信息：</p><p><img src="/2023/12/06/linux-collection-funny-commands/Users/leo/share/git_internal/mycode/3-Minutes-Programming/linux/images/lolcat-resolve-file.png"></p><h2 id="进入数字的魔幻世界：探秘cmatrix"><a href="#进入数字的魔幻世界：探秘cmatrix" class="headerlink" title="进入数字的魔幻世界：探秘cmatrix"></a>进入数字的魔幻世界：探秘<code>cmatrix</code></h2><p>来到黑客帝国的命令<code>cmatrix</code>，这不仅仅是一串字符在终端中的运动，它仿佛是数字的舞蹈，变幻着无穷的图案。从绿色的数字雨到模拟Matrix电影的效果，<code>cmatrix</code>让我们进入了数字的奇妙世界。</p><p><img src="/2023/12/06/linux-collection-funny-commands/Users/leo/share/git_internal/mycode/3-Minutes-Programming/linux/images/linux-cmatrix.png"></p><h2 id="显示系统风貌的screenfetch命令"><a href="#显示系统风貌的screenfetch命令" class="headerlink" title="显示系统风貌的screenfetch命令"></a>显示系统风貌的screenfetch命令</h2><p><code>screenfetch</code>命令的神奇之处在于其简单而又直观的功能，该命令能够快速地收集系统信息并以一种富有个性的方式展示出来。</p><p>从使用的发行版到内核版本，再到处理器和内存，一目了然地展现系统的全貌。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">$ screenfetch</span><br><span class="line">                          ./+o+-       oper@localhost</span><br><span class="line">                  yyyyy- -yyyyyy+      OS: Ubuntu </span><br><span class="line">               ://+//////-yyyyyyo      Kernel: aarch64 Linux 6.4.16-linuxkit</span><br><span class="line">           .++ .:/++++++/-.+sss/`      Uptime: 33m</span><br><span class="line">         .:++o:  /++++++++/:--:/-      Packages: 134</span><br><span class="line">        o:+o+:++.`..```.-/oo+++++/     Shell: bash 5.1.16</span><br><span class="line">       .:+o:+o/.          `+sssoo+/    Disk: 32G / 59G (57%)</span><br><span class="line">  .++/+:+oo+o:`             /sssooo.   CPU: 12x Apple</span><br><span class="line"> /+++//+:`oo+o               /::--:.   RAM: 877MiB / 7844MiB</span><br><span class="line"> \+/+o+++`o++o               ++////.  </span><br><span class="line">  .++.o+++oo+:`             /dddhhh.  </span><br><span class="line">       .+.o+oo:.          `oddhhhh+   </span><br><span class="line">        \+.++o+o``-````.:ohdhhhhh+    </span><br><span class="line">         `:o+++ `ohhhhhhhhyo++os:     </span><br><span class="line">           .o:`.syhhhhhhh/.oo++o`     </span><br><span class="line">               /osyyyyyyo++ooo+++/    </span><br><span class="line">                   ````` +oo+++o\:    </span><br><span class="line">                          `oo++.  </span><br></pre></td></tr></tbody></table></figure><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Linux最有趣的几个命令&quot;&gt;&lt;a href=&quot;#Linux最有趣的几个命令&quot; class=&quot;headerlink&quot; title=&quot;Linux最有趣的几个命令&quot;&gt;&lt;/a&gt;Linux最有趣的几个命令&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;仅个人想法，会持续不间断更</summary>
      
    
    
    
    <category term="Linux集锦" scheme="http://shaoguangleo.github.io/categories/Linux%E9%9B%86%E9%94%A6/"/>
    
    
    <category term="Linux" scheme="http://shaoguangleo.github.io/tags/Linux/"/>
    
    <category term="cmatrix" scheme="http://shaoguangleo.github.io/tags/cmatrix/"/>
    
    <category term="Linux汇总" scheme="http://shaoguangleo.github.io/tags/Linux%E6%B1%87%E6%80%BB/"/>
    
    <category term="有趣命令" scheme="http://shaoguangleo.github.io/tags/%E6%9C%89%E8%B6%A3%E5%91%BD%E4%BB%A4/"/>
    
    <category term="screenfetch" scheme="http://shaoguangleo.github.io/tags/screenfetch/"/>
    
    <category term="sl" scheme="http://shaoguangleo.github.io/tags/sl/"/>
    
    <category term="figlet" scheme="http://shaoguangleo.github.io/tags/figlet/"/>
    
    <category term="cowsay" scheme="http://shaoguangleo.github.io/tags/cowsay/"/>
    
    <category term="fortunes" scheme="http://shaoguangleo.github.io/tags/fortunes/"/>
    
    <category term="lolcat" scheme="http://shaoguangleo.github.io/tags/lolcat/"/>
    
    <category term="toilet" scheme="http://shaoguangleo.github.io/tags/toilet/"/>
    
  </entry>
  
  <entry>
    <title>Linux最常用的硬件相关的命令</title>
    <link href="http://shaoguangleo.github.io/2023/11/18/linux-collection-hardware-commands/"/>
    <id>http://shaoguangleo.github.io/2023/11/18/linux-collection-hardware-commands/</id>
    <published>2023-11-18T14:28:00.000Z</published>
    <updated>2025-06-19T13:19:18.872Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux最常用的硬件相关的命令"><a href="#Linux最常用的硬件相关的命令" class="headerlink" title="Linux最常用的硬件相关的命令"></a>Linux最常用的硬件相关的命令</h1><blockquote><p>仅个人想法，会持续不间断更新和改进。</p></blockquote><p>怎么忽然来硬的呢，因为在Linux的世界中，系统是灵活，但是骨架同样重要。</p><p>而跟踪确认硬件信息对于我们同样重要。</p><p>同时还增加了系统的关机。</p><hr><h2 id="查看块设备的lsblk"><a href="#查看块设备的lsblk" class="headerlink" title="查看块设备的lsblk"></a>查看块设备的lsblk</h2><p> <code>lsblk</code> 命令可以查看系统中的块设备信息</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ lsblk</span><br></pre></td></tr></tbody></table></figure><p>这个命令会列出系统中所有的块设备（比如硬盘、分区和挂载点）的信息。</p><p>默认情况下，它会显示每个设备的名称、大小、类型、挂载点等信息。</p><p>如果需要显示更详细的信息，可以使用 <code>-a</code> 或 <code>--all</code> 选项：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ lsblk -a</span><br></pre></td></tr></tbody></table></figure><p>这会显示完整的块设备信息，包括未挂载的设备。</p><p>当然，还可以根据需求，定制化输出，不过单单这个命令，足矣。</p><h2 id="显示管理磁盘分区-fdisk"><a href="#显示管理磁盘分区-fdisk" class="headerlink" title="显示管理磁盘分区 fdisk"></a>显示管理磁盘分区 fdisk</h2><p><code>fdisk</code>是用于检查一个磁盘上分区信息最通用的命令。</p><p><code>fdisk</code>可以显示分区信息及一些细节信息，比如文件系统类型等。</p><p>设备的名称通常是<u>/dev/sda、/dev/sdb</u> 等。</p><p>对于以前的设备有可能还存在设备名为 /dev/hd* (IDE)的设备，这个设备逐步淘汰了。</p><p><code>fdisk</code>也可以用于创建并操控分区表信息，支持主任GPU、MBR、Sun、SGI和BSD。</p><p>块设备可以划分为一个或多个称为分区的逻辑磁盘。这种划分的记录会保存在分区表，通常位于磁盘的第 0 扇区。</p><p>fdisk的官方解释为：</p><blockquote><p>fdisk - manipulate disk partition table</p></blockquote><p>语法格式为：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ fdisk [options] device</span><br><span class="line"></span><br><span class="line">$ fdisk -l [device...]</span><br></pre></td></tr></tbody></table></figure><p>其中一些常用的参数为：</p><ul><li><code>-l</code>  列出指定的外围设备的分区表状况</li><li><code>-L, --color[=when]</code> ：将输出颜色化，其中when可以指定为auto, never or always. 默认为 auto.</li></ul><h3 id="显示当前系统的分区情况"><a href="#显示当前系统的分区情况" class="headerlink" title="显示当前系统的分区情况"></a>显示当前系统的分区情况</h3><p>这个也是我唯一推荐入门者使用的 命令，仅仅list显示出目前的系统分区。</p><p>万万不要输入fdisk执行其他操作，极易格式化硬盘，切记切记。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ fdisk -l</span><br><span class="line">WARNING: fdisk GPT support is currently new, and therefore <span class="keyword">in</span> an experimental phase. Use at your own discretion.</span><br><span class="line"></span><br><span class="line">Disk /dev/sda: 256.1 GB, 256060514304 bytes, 500118192 sectors <span class="comment"># 磁盘空间及扇区信息</span></span><br><span class="line">Units = sectors of 1 * 512 = 512 bytes</span><br><span class="line">Sector size (logical/physical): 512 bytes / 512 bytes</span><br><span class="line">I/O size (minimum/optimal): 512 bytes / 512 bytes</span><br><span class="line">Disk label <span class="built_in">type</span>: gpt</span><br><span class="line">Disk identifier: FAF37680-0ECE-4BE7-93FC-E87A8F2F6455</span><br></pre></td></tr></tbody></table></figure><h2 id="显示硬件信息的hwinfo"><a href="#显示硬件信息的hwinfo" class="headerlink" title="显示硬件信息的hwinfo"></a>显示硬件信息的hwinfo</h2><p><code>hwinfo</code> 又一个用于显示硬件信息的命令。</p><p>可以获得 Linux 系统的各种硬件组件（如CPU、内存、显卡、硬盘等）的详细信息。</p><h3 id="显示所有硬件信息："><a href="#显示所有硬件信息：" class="headerlink" title="显示所有硬件信息："></a><strong>显示所有硬件信息</strong>：</h3>   <figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> hwinfo</span><br></pre></td></tr></tbody></table></figure><p>   列出系统上几乎所有可用硬件的详细信息。</p><h3 id="指定特定硬件信息："><a href="#指定特定硬件信息：" class="headerlink" title="指定特定硬件信息："></a><strong>指定特定硬件信息</strong>：</h3>   <figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> hwinfo --cpu</span><br><span class="line"><span class="built_in">sudo</span> hwinfo --memory</span><br><span class="line"><span class="built_in">sudo</span> hwinfo --gfxcard</span><br><span class="line"><span class="built_in">sudo</span> hwinfo --disk</span><br></pre></td></tr></tbody></table></figure><p>   通过在命令后添加 <code>--cpu</code>、<code>--memory</code>、<code>--gfxcard</code>、<code>--disk</code> 等参数，获取特定硬件的信息。</p><h2 id="列出系统硬件信息的lshw"><a href="#列出系统硬件信息的lshw" class="headerlink" title="列出系统硬件信息的lshw"></a>列出系统硬件信息的lshw</h2><p><code>lshw</code>是<code>Hardware Lister </code>的缩写，直面意思即列出系统硬件信息。</p><p>可以显示关于计算机硬件组件（如处理器、内存、硬盘、网卡等）的详细信息，对于系统管理员和用户来说是一个非常有用的工具。</p><h3 id="显示所有硬件信息"><a href="#显示所有硬件信息" class="headerlink" title="显示所有硬件信息"></a>显示所有硬件信息</h3><p>任何参数都不加的话，可用，信息极多，但是可用信息不多。</p> <figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> lshw</span><br></pre></td></tr></tbody></table></figure><p>  这将输出系统中所有可用硬件的详细信息，包括硬件组件的制造商、型号、驱动程序等。</p><h3 id="查看摘要硬件信息"><a href="#查看摘要硬件信息" class="headerlink" title="查看摘要硬件信息"></a>查看摘要硬件信息</h3><p><strong>显示摘要信息</strong>：相对而言，这个反而好一些，简单的就是有用的</p>  <figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> lshw -short</span><br></pre></td></tr></tbody></table></figure><p>  这将显示硬件的摘要信息，包括设备名、类别、描述等。</p><h3 id="查看特定硬件信息（如网络、内存、硬盘等设备）"><a href="#查看特定硬件信息（如网络、内存、硬盘等设备）" class="headerlink" title="查看特定硬件信息（如网络、内存、硬盘等设备）"></a>查看特定硬件信息（如网络、内存、硬盘等设备）</h3><p><strong>显示指定类型的硬件信息</strong>：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> lshw -C network</span><br></pre></td></tr></tbody></table></figure><p>上述示例将仅显示网络相关的硬件信息。</p><p>比如还可以查看<code>memory</code>、<code>cpu</code>、<code>disk</code>等信息。</p><p><code>lshw</code>提供了全面的硬件信息，帮助用户了解系统配置和硬件组件的细节。在查看和诊断硬件问题或了解系统配置时，它是一个非常有用的工具。</p><h2 id="放空一下自我-free"><a href="#放空一下自我-free" class="headerlink" title="放空一下自我  free"></a>放空一下自我  free</h2><p>**<code>free</code>**这个命令在Linux系统监控的工具里面，算是使用的比较多的一个。</p><p>使用_<code>man</code>_查看可知，官方含义为：</p><blockquote><p>Display amount of free and used memory in the system</p></blockquote><p>也就是显示可用、易用的系统内存，它直接读取<code>/proc/meminfo</code>文件。</p><h3 id="默认的效果"><a href="#默认的效果" class="headerlink" title="默认的效果"></a>默认的效果</h3><p>先看下不加任何参数的时候，<code>free</code>的效果：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ free</span><br><span class="line">              total        used        free      shared  buff/cache   available</span><br><span class="line">Mem:       32664832    15667736      674136      464892    16322960    15803156</span><br><span class="line">Swap:      16449532     3039756    13409776</span><br></pre></td></tr></tbody></table></figure><p>看起来很多的样子，但是不直观，我比较喜欢加上-h参数。</p><h3 id="使用易读的参数"><a href="#使用易读的参数" class="headerlink" title="使用易读的参数"></a>使用易读的参数</h3><p><strong>-h</strong>参数，跟前面的<code>df</code>等命令类似，此处的h表示_human being_的含义方便人类阅读。 除了这个还有_-b,-k,-m,-g_，含义分别为按照_字节、KB、MB、GB_的格式来显示。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ free -h</span><br><span class="line">              total        used        free      shared  buff/cache   available</span><br><span class="line">Mem:            31G         14G        655M        453M         15G         15G</span><br><span class="line">Swap:           15G        2.9G         12G</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>Wow，此时的显示简直好简洁。</p><p>说下其中的含义:</p><ul><li><p><u>total</u> : 表示总的物理内存大小，比如上面的就表示31GB的内存</p></li><li><p><u>used</u> ：表示已经使用的内存大小，比如上面的就是使用了14GB</p></li><li><p><u>free</u> ：表示可用多少</p></li><li><p><u>shared</u>：表示多个进程共享的内存大小</p></li><li><p><u>buff/cache</u>：表示磁盘缓存的大小，这里有两个方面，<code>buff</code>和<code>cache</code>，两个的含义不同</p><ul><li><u>buff</u> ：something that has yet to be ‘writeen’ to disk ,还没有写入磁盘</li><li><u>cache</u>: something that had been ‘read’ from the disk and store for later user，从磁盘读取的方便下一次使用</li><li>这里就设计到Linux的设计哲学，比如读取一个100G的文件，第一次所使用的时间总归是后面再次读取的时间的好几倍，当然前提是没有释放掉caches</li></ul></li><li><p><u>available</u>：当然含义为可用的内存容量大小</p></li></ul><h3 id="间隔显示内存状态"><a href="#间隔显示内存状态" class="headerlink" title="间隔显示内存状态"></a>间隔显示内存状态</h3><p>还有一个比较常用的就是，如果你希望过一段时间就看下<code>free</code>的情况，OK，使用参数<code>-s</code>，后面跟的单位是秒，也就是每个几秒，统计一下使用的内存情况，比如我们每个2s，显示一下</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$ free -s 2</span><br><span class="line">              total        used        free      shared  buff/cache   available</span><br><span class="line">Mem:       32664832    15668528      670964      464892    16325340    15802360</span><br><span class="line">Swap:      16449532     3039756    13409776</span><br><span class="line"></span><br><span class="line">              total        used        free      shared  buff/cache   available</span><br><span class="line">Mem:       32664832    15669760      669724      464892    16325348    15801124</span><br><span class="line">Swap:      16449532     3039756    13409776</span><br><span class="line"></span><br><span class="line">              total        used        free      shared  buff/cache   available</span><br><span class="line">Mem:       32664832    15670220      669248      464892    16325364    15800652</span><br><span class="line">Swap:      16449532     3039756    13409776</span><br><span class="line"></span><br><span class="line">              total        used        free      shared  buff/cache   available</span><br><span class="line">Mem:       32664832    15669264      670204      464892    16325364    15801624</span><br><span class="line">Swap:      16449532     3039756    13409776</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h3 id="查看meminfo文件"><a href="#查看meminfo文件" class="headerlink" title="查看meminfo文件"></a>查看meminfo文件</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cat</span> /proc/meminfo</span><br></pre></td></tr></tbody></table></figure><p>其实<code>free</code>读取的就是这个文件的某些信息，可以通过同步监控这个文件来check <code>free</code>的状态。</p><h2 id="显示CPU架构的有关信息-lscpu"><a href="#显示CPU架构的有关信息-lscpu" class="headerlink" title="显示CPU架构的有关信息 lscpu"></a>显示CPU架构的有关信息 lscpu</h2><p>Linux的CPU设备查看器。<code>lscpu</code>命令用来显示<strong>cpu</strong>的相关信息。<br><code>lscpu</code>从<u>sysfs</u>和<u>/proc/cpuinfo</u>收集<strong>cpu</strong>体系结构信息，命令的输出比较易读 。<br>命令输出的信息包含<strong>cpu</strong>数量，线程，核数，socket和Nom-Uniform Memeor Access(NUMA)，缓存等等。</p><p>官方定义为：</p><blockquote><p><code>lscpu</code> - display information about the CPU architecture</p></blockquote><p>参数基本用处不大，默认即可，部分参数可以查看offline和online的设备信息。</p><h3 id="默认实例"><a href="#默认实例" class="headerlink" title="默认实例"></a>默认实例</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">$ lscpu</span><br><span class="line">Architecture:          x86_64       <span class="comment">#架构信息 </span></span><br><span class="line">CPU op-mode(s):        32-bit, 64-bit</span><br><span class="line">Byte Order:            Little Endian</span><br><span class="line">CPU(s):                64   <span class="comment">#逻辑cpu颗数 </span></span><br><span class="line">On-line CPU(s) list:   0-63</span><br><span class="line">Thread(s) per core:    2 <span class="comment">#每个核心线程</span></span><br><span class="line">Core(s) per socket:    16 <span class="comment">#每个cpu插槽核数/每颗物理cpu核数 </span></span><br><span class="line">Socket(s):             2  <span class="comment">#cpu插槽数</span></span><br><span class="line">NUMA node(s):          2</span><br><span class="line">Vendor ID:             GenuineIntel <span class="comment">#cpu厂商ID </span></span><br><span class="line">CPU family:            6   <span class="comment">#cpu系列 </span></span><br><span class="line">Model:                 63 <span class="comment">#型号 </span></span><br><span class="line">Model name:            Intel(R) Xeon(R) CPU E5-2698 v3 @ 2.30GHz</span><br><span class="line">Stepping:              2 <span class="comment">#步进 </span></span><br><span class="line">CPU MHz:               1290.335 <span class="comment">#cpu主频</span></span><br><span class="line">BogoMIPS:              4604.47</span><br><span class="line">Virtualization:        VT-x  <span class="comment">#cpu支持的虚拟化技术 </span></span><br><span class="line">L1d cache:             32K</span><br><span class="line">L1i cache:             32K</span><br><span class="line">L2 cache:              256K</span><br><span class="line">L3 cache:              40960K</span><br><span class="line">NUMA node0 CPU(s):     0-15,32-47</span><br><span class="line">NUMA node1 CPU(s):     16-31,48-63</span><br></pre></td></tr></tbody></table></figure><p>其中几个概念需要理解清楚，基本比较重要的都有了备注。</p><p>其中第一个为CPU(s)，这个值为Socket * Core * Thread得出，也就是逻辑的CPU个数。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CPU(s):                64   <span class="comment">#逻辑CPU数</span></span><br><span class="line">On-line CPU(s) list:   0-63</span><br><span class="line">Thread(s) per core:    2     </span><br><span class="line">Core(s) per socket:    16</span><br><span class="line">socket：                2</span><br></pre></td></tr></tbody></table></figure><p>而其他几个概念为：</p><ul><li>Socket : 物理上的CPU插槽的数量，也就是物理的实体概念</li><li>Core：即平常说的单核、多核、四核等，即每个CPU上的核数</li><li>Thread：每个core上的线程数，即超线程。</li></ul><h2 id="lspci-显示当前设备的PCI总线信息"><a href="#lspci-显示当前设备的PCI总线信息" class="headerlink" title="lspci 显示当前设备的PCI总线信息"></a>lspci 显示当前设备的PCI总线信息</h2><p><code>lspci</code>命令用于显示PCI总线的信息，以及所有已连接的PCI设备信息。</p><p>官方定义为：</p><blockquote><p><code>lspci </code> - list all PCI devices</p></blockquote><p>默认情况下，<code>lspci</code>会显示一个简短的设备列表。 使用使用一些参数来显示更详细的输出或供其他程序解析的输出。</p><p>不过需要<u>注意</u>的是，在许多操作系统上，对 PCI 配置空间的某些部分的访问仅限于 root，因此普通用户可用的 lspci 功能受到限制。</p><p>使用方法为：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ lspci [options]</span><br></pre></td></tr></tbody></table></figure><p>其中常用的三个选项为：</p><ul><li><code>-n</code>  以数字方式显示PCI厂商和设备代码</li><li><code>-t</code> 以树状结构显示PCI设备的层次关系</li><li><code>-v</code> 显示更详细的输出信息</li></ul><h3 id="显示当前主机的所有PCI总线信息："><a href="#显示当前主机的所有PCI总线信息：" class="headerlink" title="显示当前主机的所有PCI总线信息："></a>显示当前主机的所有PCI总线信息：</h3><p>默认无参数的显示</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ lspci</span><br><span class="line">00:00.0 Host bridge: Intel Corporation Xeon E7 v3/Xeon E5 v3/Core i7 DMI2 (rev 02)</span><br><span class="line">00:01.0 PCI bridge: Intel Corporation Xeon E7 v3/Xeon E5 v3/Core i7 PCI Express Root Port 1 (rev 02)</span><br><span class="line">00:02.0 PCI bridge: Intel Corporation Xeon E7 v3/Xeon E5 v3/Core i7 PCI Express Root Port 2 (rev 02)</span><br><span class="line">00:03.0 PCI bridge: Intel Corporation Xeon E7 v3/Xeon E5 v3/Core i7 PCI Express Root Port 3 (rev 02)</span><br><span class="line">00:03.2 PCI bridge: Intel Corporation Xeon E7 v3/Xeon E5 v3/Core i7 PCI Express Root Port 3 (rev 02)</span><br><span class="line">00:04.0 System peripheral: Intel Corporation Xeon E7 v3/Xeon E5 v3/Core i7 DMA Channel 0 (rev 02)</span><br><span class="line">00:04.1 System peripheral: Intel Corporation Xeon E7 v3/Xeon E5 v3/Core i7 DMA Channel 1 (rev 02)</span><br><span class="line">00:04.2 System peripheral: Intel Corporation Xeon E7 v3/Xeon E5 v3/Core i7 DMA Channel 2 (rev 02)</span><br><span class="line">......</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h3 id="以数字方式显示PCI厂商和设备代码"><a href="#以数字方式显示PCI厂商和设备代码" class="headerlink" title="以数字方式显示PCI厂商和设备代码"></a>以数字方式显示PCI厂商和设备代码</h3><p>以数字形式显示</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ lspci -n</span><br><span class="line">00:00.0 0600: 8086:2f00 (rev 02)</span><br><span class="line">00:01.0 0604: 8086:2f02 (rev 02)</span><br><span class="line">00:02.0 0604: 8086:2f04 (rev 02)</span><br><span class="line">00:03.0 0604: 8086:2f08 (rev 02)</span><br><span class="line">00:03.2 0604: 8086:2f0a (rev 02)</span><br><span class="line">00:04.0 0880: 8086:2f20 (rev 02)</span><br><span class="line">00:04.1 0880: 8086:2f21 (rev 02)</span><br><span class="line">00:04.2 0880: 8086:2f22 (rev 02)</span><br><span class="line">......</span><br></pre></td></tr></tbody></table></figure><h3 id="同时显示数字方式还有设备代码信息"><a href="#同时显示数字方式还有设备代码信息" class="headerlink" title="同时显示数字方式还有设备代码信息"></a>同时显示数字方式还有设备代码信息</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ lspci -nn</span><br><span class="line">00:00.0 Host bridge [0600]: Intel Corporation Xeon E7 v3/Xeon E5 v3/Core i7 DMI2 [8086:2f00] (rev 02)</span><br><span class="line">00:01.0 PCI bridge [0604]: Intel Corporation Xeon E7 v3/Xeon E5 v3/Core i7 PCI Express Root Port 1 [8086:2f02] (rev 02)</span><br><span class="line">00:02.0 PCI bridge [0604]: Intel Corporation Xeon E7 v3/Xeon E5 v3/Core i7 PCI Express Root Port 2 [8086:2f04] (rev 02)</span><br><span class="line">00:03.0 PCI bridge [0604]: Intel Corporation Xeon E7 v3/Xeon E5 v3/Core i7 PCI Express Root Port 3 [8086:2f08] (rev 02)</span><br><span class="line">00:03.2 PCI bridge [0604]: Intel Corporation Xeon E7 v3/Xeon E5 v3/Core i7 PCI Express Root Port 3 [8086:2f0a] (rev 02)</span><br><span class="line">00:04.0 System peripheral [0880]: Intel Corporation Xeon E7 v3/Xeon E5 v3/Core i7 DMA Channel 0 [8086:2f20] (rev 02)</span><br><span class="line">00:04.1 System peripheral [0880]: Intel Corporation Xeon E7 v3/Xeon E5 v3/Core i7 DMA Channel 1 [8086:2f21] (rev 02)</span><br><span class="line">00:04.2 System peripheral [0880]: Intel Corporation Xeon E7 v3/Xeon E5 v3/Core i7 DMA Channel 2 [8086:2f22] (rev 02)</span><br><span class="line">......</span><br></pre></td></tr></tbody></table></figure><h3 id="以树状结构显示PCI设备的层次关系："><a href="#以树状结构显示PCI设备的层次关系：" class="headerlink" title="以树状结构显示PCI设备的层次关系："></a>以树状结构显示PCI设备的层次关系：</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ lspci -t</span><br><span class="line">lspci -t</span><br><span class="line">-+-[0000:ff]-+-08.0</span><br><span class="line"> |           +-08.2</span><br><span class="line"> |           +-1f.0</span><br><span class="line"> |           \-1f.2</span><br><span class="line"> +-[0000:80]-+-01.0-[81]----00.0</span><br><span class="line"> |           +-04.0</span><br><span class="line"> |           +-05.1</span><br><span class="line"> |           +-05.2</span><br><span class="line"> |           \-05.4</span><br><span class="line"> +-[0000:7f]-+-08.0</span><br><span class="line"> |           +-08.2</span><br><span class="line"> |           +-0c.1</span><br><span class="line">             \+-0c.2</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h2 id="Linux-reboot-x2F-poweroff-x2F-halt-命令"><a href="#Linux-reboot-x2F-poweroff-x2F-halt-命令" class="headerlink" title="Linux reboot/poweroff/halt 命令"></a>Linux reboot/poweroff/halt 命令</h2><p>Linux <code>halt</code>, <code>poweroff</code>, <code>reboot</code> 用来挂起、关机或者重启机器，成功后返回0。</p><p>这不是一个命令，这是三个命令，只不过三个命令的参数都是一致的。</p><p>官方定义为：</p><blockquote><p><code>halt, poweroff, reboot</code> - Halt, power-off or reboot the machine</p></blockquote><p>其实这三个命令都可以通过<code>shutdown</code>来执行，并且相对而言<code>shutdown</code>的参数还更多一些。</p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p>使用方法如下：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ halt [OPTIONS...]</span><br><span class="line"></span><br><span class="line">$ poweroff [OPTIONS...]</span><br><span class="line">    </span><br><span class="line">$ reboot [OPTIONS...]</span><br></pre></td></tr></tbody></table></figure><p>参数如下所示：</p><ul><li><code>--halt</code> 将机器挂起，三个命令均相同</li><li><code>-p, --poweroff</code>  将机器关机，三个命令均相同</li><li><code>--reboot</code>  将机器重启，三个命令均相同</li><li><code>-f, --force</code> 立即执行挂起、关机和重启，一般对于<u>force</u>而言，除非万不得已，否则进来莫用</li><li><code>-n, --no-sync</code> 在挂起、关机或重启前不对硬盘进行同步，这个很危险呀，进来不要用呀</li><li><code>--no-wall</code> 在挂起、关机或重启前不发送警告信息，对于多用户不友好</li></ul><h3 id="立即关机"><a href="#立即关机" class="headerlink" title="立即关机"></a>立即关机</h3><p>接下来的三个命令一致，都是将电脑关机，不过这个用法总归感觉怪怪的，所以还是分开各司其职比较好。比如关机还是<code>poweroff</code>，重启还是<code>reboot</code>吧。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ halt --poweroff</span><br><span class="line"></span><br><span class="line">$ poweroff --poweroff</span><br><span class="line"></span><br><span class="line">$ reboot --poweroff</span><br></pre></td></tr></tbody></table></figure><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Linux最常用的硬件相关的命令&quot;&gt;&lt;a href=&quot;#Linux最常用的硬件相关的命令&quot; class=&quot;headerlink&quot; title=&quot;Linux最常用的硬件相关的命令&quot;&gt;&lt;/a&gt;Linux最常用的硬件相关的命令&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;仅</summary>
      
    
    
    
    <category term="Linux集锦" scheme="http://shaoguangleo.github.io/categories/Linux%E9%9B%86%E9%94%A6/"/>
    
    
    <category term="Linux" scheme="http://shaoguangleo.github.io/tags/Linux/"/>
    
    <category term="rm" scheme="http://shaoguangleo.github.io/tags/rm/"/>
    
    <category term="Linux汇总" scheme="http://shaoguangleo.github.io/tags/Linux%E6%B1%87%E6%80%BB/"/>
    
    <category term="危险命令" scheme="http://shaoguangleo.github.io/tags/%E5%8D%B1%E9%99%A9%E5%91%BD%E4%BB%A4/"/>
    
    <category term="dd" scheme="http://shaoguangleo.github.io/tags/dd/"/>
    
    <category term="mkfs" scheme="http://shaoguangleo.github.io/tags/mkfs/"/>
    
    <category term="shutdown" scheme="http://shaoguangleo.github.io/tags/shutdown/"/>
    
    <category term="硬件信息" scheme="http://shaoguangleo.github.io/tags/%E7%A1%AC%E4%BB%B6%E4%BF%A1%E6%81%AF/"/>
    
    <category term="reboot" scheme="http://shaoguangleo.github.io/tags/reboot/"/>
    
    <category term="poweroff" scheme="http://shaoguangleo.github.io/tags/poweroff/"/>
    
    <category term="halt" scheme="http://shaoguangleo.github.io/tags/halt/"/>
    
  </entry>
  
  <entry>
    <title>Linux最常用的几个软件包管理命令</title>
    <link href="http://shaoguangleo.github.io/2023/11/18/linux-collection-package-managerment/"/>
    <id>http://shaoguangleo.github.io/2023/11/18/linux-collection-package-managerment/</id>
    <published>2023-11-18T14:28:00.000Z</published>
    <updated>2025-06-19T13:19:18.872Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux最常用的几个软件包管理命令"><a href="#Linux最常用的几个软件包管理命令" class="headerlink" title="Linux最常用的几个软件包管理命令"></a>Linux最常用的几个软件包管理命令</h1><blockquote><p>仅个人想法，会持续不间断更新和改进。</p></blockquote><p>软件安装，应该算是Linux系统中最常见的操作之一，而软件包管理命令，也是我们在Linux系统中最常用的命令之一。</p><p>但凡系统安装好以后，第一件事情就是更新软件包，然后安装自己需要的软件包，这是一个很常见的操作。</p><p>Linux不同与Windows，直接下载一个exe文件双击就可以安装，Linux系统需要命令行来安装软件包，这是一个很大的区别。</p><p>而用于安装、更新、删除软件包，以及管理系统的软件包又由于不同的Linux发行版，由不同的方式，比如<code>apt</code>、<code>yum</code>、<code>dpkg</code>、<code>rpm</code>等。</p><hr><h2 id="软件管理利器-Debian系的apt"><a href="#软件管理利器-Debian系的apt" class="headerlink" title="软件管理利器  - Debian系的apt"></a>软件管理利器  - Debian系的apt</h2><p>对于最常用的命令而言，<code>apt</code>可能排不上号，但是，在新安装的系统中，<code>apt</code> 命令绝对应该是排在前十位的存在，所以<code>apt</code>是管理 Debian 系列系统中软件包的必备工具。</p><blockquote><p>apt - command-line interface</p></blockquote><p>apt是Advanced Package Tool的缩写，恰如字面描述<strong>高级包工具</strong>，<code>apt</code> 命令是用于 Debian 系列 Linux 发行版的强大工具，比如广为人知的Ubuntu，还有超赞桌面的Linux Mint。</p><p><code>apt</code>使得处理软件包，比如安装、更新和删除软件包的过程特别丝滑，也结合了较早的工具如 <code>apt-get</code> 和 <code>apt-cache</code> 的功能，提供了更友好的交互体验。</p><h3 id="更新软件包列表"><a href="#更新软件包列表" class="headerlink" title="更新软件包列表"></a>更新软件包列表</h3><p>在安装或升级软件包之前，可以更新软件包列表，以确保拥有可用软件包的最新信息。</p><p>使用以下命令：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">sudo</span> apt update</span><br></pre></td></tr></tbody></table></figure><p>此命令从配置的仓库中获取最新的软件包信息。</p><h3 id="升级软件包"><a href="#升级软件包" class="headerlink" title="升级软件包"></a>升级软件包</h3><p>要将所有已安装的软件包升级到最新版本，可以使用：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">sudo</span> apt upgrade</span><br></pre></td></tr></tbody></table></figure><p>要进行更全面的升级，包括删除旧软件包和安装新依赖项，请使用：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">sudo</span> apt full-upgrade <span class="comment"># 特别留意，这个会把老版本给删除</span></span><br></pre></td></tr></tbody></table></figure><h3 id="安装软件包"><a href="#安装软件包" class="headerlink" title="安装软件包"></a>安装软件包</h3><p><code>apt</code> 命令使得软件包安装变得非常简单。要安装一个软件包，只需要使用：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">sudo</span> apt install &lt;软件包名称&gt;</span><br></pre></td></tr></tbody></table></figure><p>例如，要安装文本编辑器瑞士军刀 <code>vim</code>，您可以运行：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">sudo</span> apt install vim</span><br></pre></td></tr></tbody></table></figure><h3 id="删除软件包"><a href="#删除软件包" class="headerlink" title="删除软件包"></a>删除软件包</h3><p>卸载软件包同样简单。要删除一个软件包，使用：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">sudo</span> apt remove &lt;软件包名称&gt;</span><br></pre></td></tr></tbody></table></figure><p>如果您想删除软件包及其配置文件，使用：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">sudo</span> apt purge &lt;软件包名称&gt;</span><br></pre></td></tr></tbody></table></figure><h3 id="搜索软件包"><a href="#搜索软件包" class="headerlink" title="搜索软件包"></a>搜索软件包</h3><p>要查找某个软件包，可以使用关键词进行搜索：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ apt search &lt;关键词&gt;</span><br></pre></td></tr></tbody></table></figure><p>例如，要搜索与 “python” 相关的软件包，您可以运行：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ apt search python</span><br></pre></td></tr></tbody></table></figure><h3 id="显示软件包信息"><a href="#显示软件包信息" class="headerlink" title="显示软件包信息"></a>显示软件包信息</h3><p>要查看特定软件包的详细信息，使用：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ apt show &lt;软件包名称&gt;</span><br></pre></td></tr></tbody></table></figure><p>此命令提供软件包描述、依赖关系和版本信息等详细信息。</p><h3 id="清理"><a href="#清理" class="headerlink" title="清理"></a>清理</h3><p>随着时间的推移，积累过时的软件包和缓存文件。要清理不必要的软件包，使用：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">sudo</span> apt autoremove</span><br></pre></td></tr></tbody></table></figure><p>要清除本地存储库中获取的包文件，使用：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">sudo</span> apt clean</span><br></pre></td></tr></tbody></table></figure><h3 id="管理仓库"><a href="#管理仓库" class="headerlink" title="管理仓库"></a>管理仓库</h3><p><code>apt</code> 获取软件包信息的仓库列表存储在 <code>/etc/apt/sources.list</code> 及 <code>/etc/apt/sources.list.d/</code> 目录下的文件中。</p><p>要添加新的仓库，可以直接编辑这些文件或使用 <code>add-apt-repository</code> 命令：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">sudo</span> add-apt-repository ppa:&lt;仓库名称&gt;</span><br></pre></td></tr></tbody></table></figure><p>添加仓库后，需要更新软件包列表才能使用：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">sudo</span> apt update</span><br></pre></td></tr></tbody></table></figure><h2 id="红帽系的软件管理利器-yum"><a href="#红帽系的软件管理利器-yum" class="headerlink" title="红帽系的软件管理利器 - yum"></a>红帽系的软件管理利器 - yum</h2><p>.. note::<br>  当年不肯嫁春风，无端却被秋风误。<br>  贺铸《芳心苦·杨柳回塘》</p><p>我从ubuntu开始，后面短暂切换到Fedora，然后切换到CentOS，在CentOS断更之前，再无改变，所以最了解的还是yum命令了。</p><p>官方定义为：</p><blockquote><p>yum -  Yellowdog Updater Modified</p></blockquote><p>说实话，yum跟yellowdog感觉半毛线关系都没有，那为什么有这个名字呢？</p><p>其实曾经有一个基于PowerPC架构的Linux发行版，名为Yellow Dog Linux。</p><p>而<code>yum</code>的名字即来源于此，且为其改进版本。</p><p><code>yum</code>是一个强大的包管理工具，常用于 Red Hat 系的 Linux 发行版，如 CentOS、Fedora 和 RHEL。</p><p>它简化了安装、更新、删除和管理软件包的过程。</p><p>基本其他基于RPM的Linux发行版也使用这个命令。</p><p>其他列出了一些常用和不太常用的命令，基本足矣。</p><h3 id="安装软件包-1"><a href="#安装软件包-1" class="headerlink" title="安装软件包"></a>安装软件包</h3><p>使用 <code>yum</code> 安装软件包的基本语法是：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">sudo</span> yum install package_name</span><br></pre></td></tr></tbody></table></figure><p>例如，要安装 <code>wget</code> 软件包，可以使用以下命令：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">sudo</span> yum install wget</span><br></pre></td></tr></tbody></table></figure><p><code>yum</code> 会自动解决依赖关系，确保所有必需的软件包都被安装。</p><h3 id="更新软件包"><a href="#更新软件包" class="headerlink" title="更新软件包"></a>更新软件包</h3><p>保持系统更新对于安全性和性能非常重要。要更新特定的软件包，使用：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">sudo</span> yum update package_name</span><br></pre></td></tr></tbody></table></figure><p>例如，更新 <code>wget</code>：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">sudo</span> yum update wget</span><br></pre></td></tr></tbody></table></figure><p>要更新所有已安装的软件包，只需运行：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">sudo</span> yum update</span><br></pre></td></tr></tbody></table></figure><h3 id="删除软件包-1"><a href="#删除软件包-1" class="headerlink" title="删除软件包"></a>删除软件包</h3><p>如果需要删除一个软件包，语法如下：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">sudo</span> yum remove package_name</span><br></pre></td></tr></tbody></table></figure><p>例如，删除 <code>wget</code>：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">sudo</span> yum remove wget</span><br></pre></td></tr></tbody></table></figure><p><code>yum</code> 将处理指定软件包的删除，并删除不再需要的依赖项。</p><h3 id="检查可用更新"><a href="#检查可用更新" class="headerlink" title="检查可用更新"></a>检查可用更新</h3><p>要检查是否有可用更新而不实际应用它们，使用：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ yum check-update</span><br></pre></td></tr></tbody></table></figure><p>此命令会列出所有有可用更新的软件包，帮助您决定哪些需要更新。</p><h3 id="列出已安装的软件包"><a href="#列出已安装的软件包" class="headerlink" title="列出已安装的软件包"></a>列出已安装的软件包</h3><p>要列出系统上所有已安装的软件包，运行：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ yum list installed</span><br></pre></td></tr></tbody></table></figure><p>此命令提供了当前已安装的所有软件包的详细列表。</p><h3 id="搜索软件包-1"><a href="#搜索软件包-1" class="headerlink" title="搜索软件包"></a>搜索软件包</h3><p>如果不确定软件包的确切名称，可以使用：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ yum search keyword</span><br></pre></td></tr></tbody></table></figure><p>例如，搜索与 <code>wget</code> 相关的软件包：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ yum search wget</span><br></pre></td></tr></tbody></table></figure><p>此命令会返回与关键字匹配的软件包列表。</p><h3 id="显示软件包信息-1"><a href="#显示软件包信息-1" class="headerlink" title="显示软件包信息"></a>显示软件包信息</h3><p>要查看特定软件包的详细信息，使用：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ yum info package_name</span><br></pre></td></tr></tbody></table></figure><p>例如，获取 <code>wget</code> 的信息：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ yum info wget</span><br></pre></td></tr></tbody></table></figure><p>此命令提供软件包的详细信息，如版本、发布、大小和简短描述。</p><h3 id="清理-yum-缓存"><a href="#清理-yum-缓存" class="headerlink" title="清理 yum 缓存"></a>清理 <code>yum</code> 缓存</h3><p>随着时间推移，<code>yum</code> 的缓存会增长并占用磁盘空间。要清理缓存，使用：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">sudo</span> yum clean all</span><br></pre></td></tr></tbody></table></figure><p>此命令会删除缓存数据，释放空间，并确保 <code>yum</code> 获取最新的软件包信息。</p><h3 id="管理仓库-1"><a href="#管理仓库-1" class="headerlink" title="管理仓库"></a>管理仓库</h3><p><code>yum</code> 使用仓库作为软件包的来源。要列出所有配置的仓库，运行：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ yum repolist</span><br></pre></td></tr></tbody></table></figure><p>启用特定仓库：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">sudo</span> yum-config-manager --<span class="built_in">enable</span> repository_name</span><br></pre></td></tr></tbody></table></figure><p>禁用特定仓库：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">sudo</span> yum-config-manager --<span class="built_in">disable</span> repository_name</span><br></pre></td></tr></tbody></table></figure><h3 id="高级用法"><a href="#高级用法" class="headerlink" title="高级用法"></a>高级用法</h3><h4 id="安装特定版本的软件包"><a href="#安装特定版本的软件包" class="headerlink" title="安装特定版本的软件包"></a>安装特定版本的软件包</h4><p>如果需要安装特定版本的软件包，使用：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">sudo</span> yum install package_name-version</span><br></pre></td></tr></tbody></table></figure><p>例如，安装 <code>wget</code> 的 <code>1.20</code> 版本：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">sudo</span> yum install wget-1.20</span><br></pre></td></tr></tbody></table></figure><h4 id="降级软件包"><a href="#降级软件包" class="headerlink" title="降级软件包"></a>降级软件包</h4><p>要将软件包降级到以前的版本，使用：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">sudo</span> yum downgrade package_name</span><br></pre></td></tr></tbody></table></figure><h4 id="组安装"><a href="#组安装" class="headerlink" title="组安装"></a>组安装</h4><p><code>yum</code> 允许您安装为特定目的而设计的一组软件包。例如，安装开发工具组，使用：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">sudo</span> yum groupinstall <span class="string">"Development Tools"</span></span><br></pre></td></tr></tbody></table></figure><h2 id="稍显底层的红帽系软件管理工具-rpm"><a href="#稍显底层的红帽系软件管理工具-rpm" class="headerlink" title="稍显底层的红帽系软件管理工具 - rpm"></a>稍显底层的红帽系软件管理工具 - rpm</h2><p>如果说yum是高大上的软件安装管理工具，那么rpm就是低调奢华的底层工具。</p><p>简洁但略显繁琐。</p><p>官方定义为：</p><blockquote><p>rpm - RPM Package Manager</p></blockquote><p>其实rpm也可以看作是Redhat Package Manager的缩写，因为rpm也是基本用于Red Hat 系的 Linux 发行版，如 CentOS、Fedora 和 RHEL。</p><p>这个命令命令主要用于安装、卸载、升级、查询和验证软件包。所以重点来了，需要<strong>软件包</strong>。</p><h3 id="安装软件包-2"><a href="#安装软件包-2" class="headerlink" title="安装软件包"></a>安装软件包</h3><p>要使用 RPM 安装软件包，基本语法是：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">sudo</span> rpm -ivh package_name.rpm</span><br></pre></td></tr></tbody></table></figure><p>比如，安装 <code>example.rpm</code> 软件包：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">sudo</span> rpm -ivh example.rpm</span><br></pre></td></tr></tbody></table></figure><p>其中：</p><ul><li><code>-i</code> 表示安装（install）</li><li><code>-v</code> 表示详细模式（verbose），显示安装过程的详细信息</li><li><code>-h</code> 表示显示进度条（hash），可视化安装进度</li></ul><h3 id="升级软件包-1"><a href="#升级软件包-1" class="headerlink" title="升级软件包"></a>升级软件包</h3><p>要升级已安装的软件包，使用：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">sudo</span> rpm -Uvh package_name.rpm</span><br></pre></td></tr></tbody></table></figure><p>比如，升级 <code>example.rpm</code>：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">sudo</span> rpm -Uvh example.rpm</span><br></pre></td></tr></tbody></table></figure><p>其中 <code>-U</code> 表示升级（upgrade），如果软件包未安装则进行安装。</p><h3 id="删除软件包-2"><a href="#删除软件包-2" class="headerlink" title="删除软件包"></a>删除软件包</h3><p>要删除已安装的软件包，语法如下：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">sudo</span> rpm -e package_name</span><br></pre></td></tr></tbody></table></figure><p>比如，删除 <code>example</code> 软件包：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">sudo</span> rpm -e example</span><br></pre></td></tr></tbody></table></figure><p>其中 <code>-e</code> 表示删除（erase）。</p><h3 id="查询软件包"><a href="#查询软件包" class="headerlink" title="查询软件包"></a>查询软件包</h3><h4 id="查询已安装的软件包"><a href="#查询已安装的软件包" class="headerlink" title="查询已安装的软件包"></a>查询已安装的软件包</h4><p>要查询系统上已安装的软件包，使用：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -qa</span><br></pre></td></tr></tbody></table></figure><p>其中 <code>-q</code> 表示查询（query），<code>-a</code> 表示所有（all）。</p><h4 id="查询特定软件包信息"><a href="#查询特定软件包信息" class="headerlink" title="查询特定软件包信息"></a>查询特定软件包信息</h4><p>要查看特定软件包的信息，使用：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ rpm -qi package_name</span><br></pre></td></tr></tbody></table></figure><p>比如，查询 <code>example</code> 软件包的信息：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ rpm -qi example</span><br></pre></td></tr></tbody></table></figure><p>其中 <code>-i</code> 表示信息（info）。</p><h4 id="查询文件属于哪个软件包"><a href="#查询文件属于哪个软件包" class="headerlink" title="查询文件属于哪个软件包"></a>查询文件属于哪个软件包</h4><p>要查询系统中文件属于哪个软件包，使用：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ rpm -qf /path/to/file</span><br></pre></td></tr></tbody></table></figure><p>比如，查询 <code>/usr/bin/example</code> 文件属于哪个软件包：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ rpm -qf /usr/bin/example</span><br></pre></td></tr></tbody></table></figure><p>其中 <code>-f</code> 表示文件（file）。</p><h3 id="验证软件包"><a href="#验证软件包" class="headerlink" title="验证软件包"></a>验证软件包</h3><p>要验证已安装的软件包，使用：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ rpm -V package_name</span><br></pre></td></tr></tbody></table></figure><p>比如，验证 <code>example</code> 软件包：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ rpm -V example</span><br></pre></td></tr></tbody></table></figure><p>其中 <code>-V</code> 表示验证（verify）。</p><h3 id="显示软件包内容"><a href="#显示软件包内容" class="headerlink" title="显示软件包内容"></a>显示软件包内容</h3><p>要显示软件包中的文件列表，使用：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ rpm -ql package_name</span><br></pre></td></tr></tbody></table></figure><p>比如，显示 <code>example</code> 软件包的文件列表：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ rpm -ql example</span><br></pre></td></tr></tbody></table></figure><p>其中 <code>-l</code> 表示列表（list）。</p><h3 id="检查软件包依赖"><a href="#检查软件包依赖" class="headerlink" title="检查软件包依赖"></a>检查软件包依赖</h3><p>要检查软件包的依赖关系，使用：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ rpm -qpR package_name.rpm</span><br></pre></td></tr></tbody></table></figure><p>比如，检查 <code>example.rpm</code> 软件包的依赖关系：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ rpm -qpR example.rpm</span><br></pre></td></tr></tbody></table></figure><h2 id="其中：-p-表示指定包文件（package）。-R-表示依赖（requires）。"><a href="#其中：-p-表示指定包文件（package）。-R-表示依赖（requires）。" class="headerlink" title="其中：- -p 表示指定包文件（package）。- -R 表示依赖（requires）。"></a>其中：<br>- <code>-p</code> 表示指定包文件（package）。<br>- <code>-R</code> 表示依赖（requires）。</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Linux最常用的几个软件包管理命令&quot;&gt;&lt;a href=&quot;#Linux最常用的几个软件包管理命令&quot; class=&quot;headerlink&quot; title=&quot;Linux最常用的几个软件包管理命令&quot;&gt;&lt;/a&gt;Linux最常用的几个软件包管理命令&lt;/h1&gt;&lt;blockquo</summary>
      
    
    
    
    <category term="Linux集锦" scheme="http://shaoguangleo.github.io/categories/Linux%E9%9B%86%E9%94%A6/"/>
    
    
    <category term="rpm" scheme="http://shaoguangleo.github.io/tags/rpm/"/>
    
    <category term="yum" scheme="http://shaoguangleo.github.io/tags/yum/"/>
    
    <category term="Linux" scheme="http://shaoguangleo.github.io/tags/Linux/"/>
    
    <category term="apt" scheme="http://shaoguangleo.github.io/tags/apt/"/>
    
    <category term="Linux汇总" scheme="http://shaoguangleo.github.io/tags/Linux%E6%B1%87%E6%80%BB/"/>
    
    <category term="软件包" scheme="http://shaoguangleo.github.io/tags/%E8%BD%AF%E4%BB%B6%E5%8C%85/"/>
    
  </entry>
  
  <entry>
    <title>Linux最危险的几个命令</title>
    <link href="http://shaoguangleo.github.io/2023/11/16/linux-collection-dangerous-commands/"/>
    <id>http://shaoguangleo.github.io/2023/11/16/linux-collection-dangerous-commands/</id>
    <published>2023-11-16T14:28:00.000Z</published>
    <updated>2025-06-19T13:19:18.871Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux最危险的几个命令"><a href="#Linux最危险的几个命令" class="headerlink" title="Linux最危险的几个命令"></a>Linux最危险的几个命令</h1><blockquote><p>仅个人想法，会持续不间断更新和改进。</p></blockquote><p>Linux系统中的命令最美妙也最危险。</p><p>如果几个操作系统（Windows/MacOSX/Linux）的危险水平有段位，那么Linux应该首当其冲。</p><p>如若使用不当，轻则伤筋动骨摔键盘，重则历年数据烟消云散。</p><p>本文本着大家熟悉其危险性，尽量避免一些误操作。</p><p>为什么Linux最危险呢？那主要是因为root 用户对系统具有绝对的操作权限，可以执行任何命令、任何操作，所以会产生任何后果。</p><p>所以在以 root 用户身份进行操作时，尤其一定要特别小心。</p><p>如果不确定命令的执行结果，可以在虚拟环境线操作一下，再在生产环境执行。</p><h2 id="危险命令介绍"><a href="#危险命令介绍" class="headerlink" title="危险命令介绍"></a>危险命令介绍</h2><p>如果单纯按照熟悉或者段位来讲，<code>rm</code>首当其冲，轻则丢点数据，重则系统崩溃。目前看到的很多删库跑路的程序员大多就因为这个。</p><blockquote><p> 特别是<code>rm -rf /</code>，不要执行，不要执行，不要执行，重要的事情说三遍，这个命令会导致整个系统被毁坏</p></blockquote><p>随后的应该就是chmod和chown，特别是对于重要的数据，一般建议对于新手而言，仅仅具备只读权限即可；</p><p>接下来的dd以及mkfs命令，可能不太常见，但是也具备一定的杀伤力。</p><p>fork炸弹暂且不表，总之随便来的命令不要随便执行。</p><hr><p>风萧萧兮易水寒，壮士一去兮不复还的 <code>rm</code> 命令。</p><blockquote><p>文件一旦通过rm命令删除，则无法恢复，所以必须格外一定切记小心地使用该命令。</p><p>因为发生过很多欲哭无泪的故事。。。</p><p>主要的痛点就在如果是在root账户权限下，rm无所不能呀</p></blockquote><p><a href="http://shaoguangleo.github.io/2011/02/12/linux-rm-beginner"> Linux的 rm 命令</a></p><h2 id="Linux-的-dd-命令"><a href="#Linux-的-dd-命令" class="headerlink" title="Linux 的 dd 命令"></a>Linux 的 dd 命令</h2><p><code>dd</code>这个命令一直没有弄明白缩写的含义，这个命令应该归到Linux炫技里面，因为我也是很晚才用到，不过有些功能还可以尝试一下。</p><p>官方含义为：</p><blockquote><p><code>dd</code> - convert and copy a file</p></blockquote><blockquote><p>从官方含义来看，是不是定义为<code>cc</code>比较合适，^_^</p></blockquote><p><code>dd</code>命令用于复制文件，转换或者格式化文件，这里也是危险所在，如果使用dd对设备进行低级别的复制和转换操作时，如果命令行参数错误，可能导致数据丢失。</p><p>比如 <code>dd if=/dev/random of=/dev/sda</code>：这个命令将设备（例如硬盘）的内容重写为随机数据，导致设备上所有数据的永久丢失。</p><h2 id="mkfs-格式化硬盘分区"><a href="#mkfs-格式化硬盘分区" class="headerlink" title="mkfs 格式化硬盘分区"></a>mkfs 格式化硬盘分区</h2><p>万万不要制定了错误的硬盘，切记切记。</p><p>这个命令格式化的很彻底。</p><h2 id="shutdown"><a href="#shutdown" class="headerlink" title="shutdown"></a>shutdown</h2><p>在root账户下，可以直接立即关闭系统，很容易造成数据没有保存，一般需要延迟个1分钟，不要使用<code>shutdown -h now</code>来立即关闭系统。</p><h2 id="gt-file"><a href="#gt-file" class="headerlink" title="> file"></a>&gt; file</h2><p><code>&gt; file</code>：这个命令会清空文件内容。若对关键的系统文件使用这个命令，可能会破坏系统。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Linux最危险的几个命令&quot;&gt;&lt;a href=&quot;#Linux最危险的几个命令&quot; class=&quot;headerlink&quot; title=&quot;Linux最危险的几个命令&quot;&gt;&lt;/a&gt;Linux最危险的几个命令&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;仅个人想法，会持续不间断更</summary>
      
    
    
    
    <category term="Linux集锦" scheme="http://shaoguangleo.github.io/categories/Linux%E9%9B%86%E9%94%A6/"/>
    
    
    <category term="Linux" scheme="http://shaoguangleo.github.io/tags/Linux/"/>
    
    <category term="rm" scheme="http://shaoguangleo.github.io/tags/rm/"/>
    
    <category term="Linux汇总" scheme="http://shaoguangleo.github.io/tags/Linux%E6%B1%87%E6%80%BB/"/>
    
    <category term="危险命令" scheme="http://shaoguangleo.github.io/tags/%E5%8D%B1%E9%99%A9%E5%91%BD%E4%BB%A4/"/>
    
    <category term="dd" scheme="http://shaoguangleo.github.io/tags/dd/"/>
    
    <category term="mkfs" scheme="http://shaoguangleo.github.io/tags/mkfs/"/>
    
    <category term="shutdown" scheme="http://shaoguangleo.github.io/tags/shutdown/"/>
    
  </entry>
  
  <entry>
    <title>Linux数据处理的几个命令</title>
    <link href="http://shaoguangleo.github.io/2023/11/16/linux-collection-data-processing-commands/"/>
    <id>http://shaoguangleo.github.io/2023/11/16/linux-collection-data-processing-commands/</id>
    <published>2023-11-16T14:28:00.000Z</published>
    <updated>2025-06-19T13:19:18.871Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux数据处理的几个命令"><a href="#Linux数据处理的几个命令" class="headerlink" title="Linux数据处理的几个命令"></a>Linux数据处理的几个命令</h1><blockquote><p>仅个人想法，会持续不间断更新和改进。</p></blockquote><p>Linux系统中的数据处理，可真假转换，可搜索，需排序、减重复。</p><hr><h2 id="真假转换之间-tr"><a href="#真假转换之间-tr" class="headerlink" title="真假转换之间 tr"></a>真假转换之间 tr</h2><p>Linux <code>tr</code> 命令用于转换或删除字符。</p><p><code>tr</code> 命令可以从标准输入读取数据，经过字符串转译后，将结果输出到标准输出。</p><p>官方定义为：</p><blockquote><p><code>tr</code> - translate or delete characters</p></blockquote><p>使用方法为：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">tr</span> [OPTION]... SET1 [SET2]</span><br></pre></td></tr></tbody></table></figure><p>其中常用的三个选项为：</p><ul><li><code>-d, --delete</code>：删除指令字符</li><li><code>[:lower:]</code> ：所有小写字母</li><li><code>[:upper:]</code> ：所有大写字母</li><li><code>[:blank:]</code> ：所有空格</li></ul><h3 id="a-z小写全部转换为大写"><a href="#a-z小写全部转换为大写" class="headerlink" title="a-z小写全部转换为大写"></a>a-z小写全部转换为大写</h3><p>默认无参数的显示</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">"Hello World, Welcome to Linux!"</span> | <span class="built_in">tr</span> a-z A-Z</span><br><span class="line">HELLO WORLD, WELCOME TO LINUX!</span><br><span class="line"></span><br><span class="line"><span class="comment"># 还有一种方法</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">"Hello World, Welcome to Linux!"</span> | <span class="built_in">tr</span> [:lower:] [:upper:]</span><br><span class="line">HELLO WORLD!</span><br></pre></td></tr></tbody></table></figure><h3 id="A-Z大写全部转换为小写"><a href="#A-Z大写全部转换为小写" class="headerlink" title="A-Z大写全部转换为小写"></a>A-Z大写全部转换为小写</h3><p>默认无参数的显示</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">"Hello World, Welcome to Linux!"</span> | <span class="built_in">tr</span>  A-Z a-z</span><br><span class="line">hello world, welcome to linux!</span><br><span class="line"></span><br><span class="line"><span class="comment"># 还有一种方法</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">"Hello World, Welcome to Linux!"</span> | <span class="built_in">tr</span> [:upper:] [:lower:]</span><br><span class="line">hello world, welcome to linux!</span><br></pre></td></tr></tbody></table></figure><h3 id="貌似起名可以用这个"><a href="#貌似起名可以用这个" class="headerlink" title="貌似起名可以用这个"></a>貌似起名可以用这个</h3><p>很多变量或者函数起名字都会移除元音字符，可以考虑使用<code>-d</code>参数，如下：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">"Hello World, Welcome to Linux!"</span> | <span class="built_in">tr</span> -d a,o,e,i</span><br><span class="line">Hll Wrld Wlcm t Lnux!</span><br></pre></td></tr></tbody></table></figure><blockquote><p>不过感觉删除的多了，也不一定是好事。。。</p><p>比如里外看Wlcm不晓得啥意思</p></blockquote><h3 id="移除文件中的所有空格"><a href="#移除文件中的所有空格" class="headerlink" title="移除文件中的所有空格"></a>移除文件中的所有空格</h3><p>同理，使用<code>-d</code>，结合<code>[:blank:]</code>可以快速删除所有空格。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">"Hello World, Welcome to Linux!"</span> | <span class="built_in">tr</span> -d [:blank:]</span><br><span class="line">HelloWorld,WelcometoLinux!</span><br></pre></td></tr></tbody></table></figure><h2 id="文件内容搜索利器-grep"><a href="#文件内容搜索利器-grep" class="headerlink" title="文件内容搜索利器 - grep"></a>文件内容搜索利器 - grep</h2><p>Linux <code>grep</code> 命令用于查找文件里符合条件的字符串。</p><p>官方定义为：</p><blockquote><p><code>grep</code>, <code>egrep</code>, <code>fgrep</code> - print lines matching a pattern</p></blockquote><p>grep支持正则表达式，是一个强大的文本搜索工具。</p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p>语法也挺复杂，因为功能确实很强大。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ grep [OPTION...] PATTERNS [FILE...]</span><br><span class="line">$ grep [OPTION...] -e PATTERNS ... [FILE...]      <span class="comment"># 使用egrep</span></span><br><span class="line">$ grep [OPTION...] -f PATTERN_FILE ... [FILE...]  <span class="comment"># 使用fgrep</span></span><br></pre></td></tr></tbody></table></figure><p>常用的参数为：</p><ul><li><strong>-r 或 –recursive</strong> : 此参数的效果和指定”-d recurse”参数相同</li><li><strong>-v 或 –invert-match</strong> : 显示不包含匹配文本的所有行</li><li><strong>-i 或 –ignore-case</strong> : 忽略字符大小写的差别</li><li><strong>-n 或 –line-number</strong> : 在显示符合样式的那一行之前，标示出该行的列数编号。</li></ul><p>假定有如下3个文件，1个文件夹，内容如下：</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">a</span></span><br><span class="line">    This is <span class="selector-tag">a</span></span><br><span class="line">    Hello <span class="selector-tag">a</span></span><br><span class="line">    </span><br><span class="line"><span class="selector-tag">b</span> </span><br><span class="line">    this is <span class="selector-tag">b</span></span><br><span class="line">    Hello <span class="selector-tag">b</span></span><br><span class="line">c </span><br><span class="line">    This is c</span><br><span class="line">    Hello c</span><br><span class="line"></span><br><span class="line">d/d </span><br><span class="line">    This is d</span><br><span class="line">    Hello d</span><br></pre></td></tr></tbody></table></figure><h3 id="默认无参数"><a href="#默认无参数" class="headerlink" title="默认无参数"></a>默认无参数</h3><p>在当前目录搜索包含<strong>is</strong>字符串，可以看到**<u>a/b/c</u>**三个文件均有输出，而<u>d</u>因为是目录，暂时无输出。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ grep is *</span><br><span class="line">a:This is a</span><br><span class="line">b:this is b</span><br><span class="line">c:This is c</span><br><span class="line">grep: d: Is a directory</span><br></pre></td></tr></tbody></table></figure><h3 id="增加文件夹"><a href="#增加文件夹" class="headerlink" title="增加文件夹"></a>增加文件夹</h3><p>与其他命令类似，增加<code>-r</code>参数，递归搜索</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ grep -r is *</span><br><span class="line">a:This is a</span><br><span class="line">b:this is b</span><br><span class="line">c:This is c</span><br><span class="line">d/d:This is d</span><br></pre></td></tr></tbody></table></figure><h3 id="反向查找"><a href="#反向查找" class="headerlink" title="反向查找"></a>反向查找</h3><p>在某些情况下，或许正想找到不包含某些字符串的内容，如下：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ grep -rv is *</span><br><span class="line">a:Hello a</span><br><span class="line">b:Hello b</span><br><span class="line">c:Hello c</span><br><span class="line">d/d:Hello d</span><br></pre></td></tr></tbody></table></figure><p>此时可以看到，不包含<strong>is</strong>的内容显示了出来。</p><h3 id="不区分大小写"><a href="#不区分大小写" class="headerlink" title="不区分大小写"></a>不区分大小写</h3><p>而某些情况下，或许我们希望找到不区分大小写的内容，比如对于<u>This/this</u>而言：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ grep -r This *</span><br><span class="line">a:This is a</span><br><span class="line">c:This is c</span><br><span class="line">d/d:This is d</span><br><span class="line"></span><br><span class="line">$ grep -ri This *</span><br><span class="line">a:This is a</span><br><span class="line">b:this is b</span><br><span class="line">c:This is c</span><br><span class="line">d/d:This is d</span><br></pre></td></tr></tbody></table></figure><p>可以看到此时有可能笔误，或者其他原因的b文件已经被找到了。</p><h3 id="显示行数，精准定位"><a href="#显示行数，精准定位" class="headerlink" title="显示行数，精准定位"></a>显示行数，精准定位</h3><p>   如果文件内容比较多，此时显示内容在哪一行，是很重要的，加上<code>-n</code>参数既可解决。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ grep -rn This *</span><br><span class="line">a:1:This is a</span><br><span class="line">c:1:This is c</span><br><span class="line">d/d:1:This is d</span><br></pre></td></tr></tbody></table></figure><h2 id="没有规矩不成方圆-sort"><a href="#没有规矩不成方圆-sort" class="headerlink" title="没有规矩不成方圆 sort"></a>没有规矩不成方圆 sort</h2><p>Linux <code>sort</code> 命令用于将文本内容进行排序。</p><p>官方定义为：</p><blockquote><p><code>sort</code> - sort lines of text files</p></blockquote><h3 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">sort</span> [OPTION]... [FILE]...</span><br><span class="line">$ <span class="built_in">sort</span> [OPTION]... --files0-from=F</span><br></pre></td></tr></tbody></table></figure><p><strong>常用的参数为</strong>：</p><ul><li><code>-c</code> 检查文件是否已经按照顺序排序。</li><li><code>-u</code> 意味着是唯一的(unique)，输出的结果是去完重了的。</li><li><code>-r</code> 以相反的顺序来排序。</li><li><code>-k field1[,field2]</code> 按指定的列进行排序。</li></ul><p>这里假定测试文件名为<u>testfile</u>：</p><figure class="highlight apache"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">LiSi</span>            <span class="number">80</span></span><br><span class="line"></span><br><span class="line"><span class="attribute">ZhangSan</span>        <span class="number">70</span></span><br><span class="line"></span><br><span class="line"><span class="attribute">WangWu</span>          <span class="number">90</span></span><br><span class="line"></span><br><span class="line"><span class="attribute">MaLiu</span>           <span class="number">88</span></span><br></pre></td></tr></tbody></table></figure><h3 id="默认无参数-1"><a href="#默认无参数-1" class="headerlink" title="默认无参数"></a>默认无参数</h3><p>在使用<code> sort</code> 命令以默认的式对文件的行进行排序，命令如下：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">sort</span> testfile </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">LiSi            80</span><br><span class="line">MaLiu           88</span><br><span class="line">WangWu          90</span><br><span class="line">ZhangSan        70</span><br></pre></td></tr></tbody></table></figure><p><code>sort</code> 命令默认情况下将第一列以 ASCII 码的次序排列，并将结果输出到标准输出。</p><h3 id="根据第N列排序"><a href="#根据第N列排序" class="headerlink" title="根据第N列排序"></a>根据第N列排序</h3><p>对于测试文件而言，或许我们更希望使用数字来统计排序，此时可以使用<code>-k N</code>参数，其中N为列数</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$  <span class="built_in">sort</span> testfile -k 2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ZhangSan        70</span><br><span class="line">LiSi            80</span><br><span class="line">MaLiu           88</span><br><span class="line">WangWu          90</span><br></pre></td></tr></tbody></table></figure><h3 id="检查是否已经排序"><a href="#检查是否已经排序" class="headerlink" title="检查是否已经排序"></a>检查是否已经排序</h3><p>在某些情况下，或许只想看看文件是否已经排序，使用<code>-c</code>参数 ：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$  <span class="built_in">sort</span> -c testfile</span><br><span class="line"><span class="built_in">sort</span>: testfile:2: disorder</span><br></pre></td></tr></tbody></table></figure><p>如果没有排序会有输出，而排序的话就没有输出。</p><h3 id="逆序排列"><a href="#逆序排列" class="headerlink" title="逆序排列"></a>逆序排列</h3><p>如果希望看一下数字从高到低的培训，使用<code>-r</code>参数：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$  <span class="built_in">sort</span> testfile -k 2  -r</span><br><span class="line">WangWu          90</span><br><span class="line">MaLiu           88</span><br><span class="line">LiSi            80</span><br><span class="line">ZhangSan        70</span><br></pre></td></tr></tbody></table></figure><h2 id="你是唯一的-uniq"><a href="#你是唯一的-uniq" class="headerlink" title="你是唯一的 uniq"></a>你是唯一的 uniq</h2><p>Linux <code>uniq</code> 命令用于检查及删除文本文件中重复出现的行列，一般与 <code>sort</code> 命令结合使用。</p><p>官方定义为：</p><blockquote><p><code>uniq</code> - report or omit repeated lines</p></blockquote><p>uniq 可检查文本文件中重复出现的行列。</p><h3 id="语法-2"><a href="#语法-2" class="headerlink" title="语法"></a>语法</h3><p>语法比较简单，直接用就可以。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">uniq</span> [OPTION]... [INPUT [OUTPUT]]</span><br></pre></td></tr></tbody></table></figure><p>常用的参数为：</p><ul><li><p><code>-c</code>或<code>--count</code> 在每列旁边显示该行重复出现的次数。</p></li><li><p><code>-d</code>或<code>--repeated</code> 仅显示重复出现的行列。</p></li><li><p><code>-u</code>或<code>--unique</code> 仅显示出一次的行列。</p></li></ul><p>假定有1个文件为<strong>testfile</strong>，内容如下：</p><figure class="highlight apache"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">testfile</span></span><br><span class="line"><span class="attribute">Hello</span> <span class="number">1</span></span><br><span class="line"><span class="attribute">Hello</span> <span class="number">2</span></span><br><span class="line"><span class="attribute">Hello</span> <span class="number">2</span></span><br><span class="line"><span class="attribute">Hello</span> <span class="number">3</span></span><br><span class="line"><span class="attribute">Hello</span> <span class="number">3</span></span><br><span class="line"><span class="attribute">Hello</span> <span class="number">3</span></span><br><span class="line"><span class="attribute">Hello</span> <span class="number">4</span></span><br><span class="line"><span class="attribute">Hello</span> <span class="number">4</span></span><br><span class="line"><span class="attribute">Hello</span> <span class="number">4</span></span><br><span class="line">    <span class="attribute">Hello</span> <span class="number">4</span></span><br></pre></td></tr></tbody></table></figure><h3 id="默认无参数-2"><a href="#默认无参数-2" class="headerlink" title="默认无参数"></a>默认无参数</h3><p>使用uniq 命令可以删除重复的行，不管有多少重复的行，仅仅显示一行。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$  <span class="built_in">uniq</span> testfile</span><br><span class="line">Hello 1</span><br><span class="line">Hello 2</span><br><span class="line">Hello 3</span><br><span class="line">Hello 4</span><br></pre></td></tr></tbody></table></figure><h3 id="统计出现频次"><a href="#统计出现频次" class="headerlink" title="统计出现频次"></a>统计出现频次</h3><p>如果希望统计每一行出现的频次，可以使用<code>-c</code>参数，其中第一行输出为出现的次数</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$  <span class="built_in">uniq</span> -c testfile</span><br><span class="line">      1 Hello 1</span><br><span class="line">      2 Hello 2</span><br><span class="line">      3 Hello 3</span><br><span class="line">      4 Hello 4</span><br></pre></td></tr></tbody></table></figure><h3 id="仅仅显示重复的行"><a href="#仅仅显示重复的行" class="headerlink" title="仅仅显示重复的行"></a>仅仅显示重复的行</h3><p>在某些情况下，或许只想看到有重复的列，使用<code>-d</code>参数 ：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$  <span class="built_in">uniq</span> -d testfile</span><br><span class="line">Hello 2</span><br><span class="line">Hello 3</span><br><span class="line">Hello 4</span><br></pre></td></tr></tbody></table></figure><h3 id="仅仅显示不重复的行"><a href="#仅仅显示不重复的行" class="headerlink" title="仅仅显示不重复的行"></a>仅仅显示不重复的行</h3><p>而某些情况下，或许只想看到不重复的列，使用<code>-u</code>参数：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$  <span class="built_in">uniq</span> -u testfile</span><br><span class="line">Hello 1</span><br></pre></td></tr></tbody></table></figure><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Linux数据处理的几个命令&quot;&gt;&lt;a href=&quot;#Linux数据处理的几个命令&quot; class=&quot;headerlink&quot; title=&quot;Linux数据处理的几个命令&quot;&gt;&lt;/a&gt;Linux数据处理的几个命令&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;仅个人想法，会持续</summary>
      
    
    
    
    <category term="Linux集锦" scheme="http://shaoguangleo.github.io/categories/Linux%E9%9B%86%E9%94%A6/"/>
    
    
    <category term="Linux" scheme="http://shaoguangleo.github.io/tags/Linux/"/>
    
    <category term="grep" scheme="http://shaoguangleo.github.io/tags/grep/"/>
    
    <category term="Linux汇总" scheme="http://shaoguangleo.github.io/tags/Linux%E6%B1%87%E6%80%BB/"/>
    
    <category term="sed" scheme="http://shaoguangleo.github.io/tags/sed/"/>
    
    <category term="awk" scheme="http://shaoguangleo.github.io/tags/awk/"/>
    
    <category term="sort" scheme="http://shaoguangleo.github.io/tags/sort/"/>
    
    <category term="uniq" scheme="http://shaoguangleo.github.io/tags/uniq/"/>
    
    <category term="tr" scheme="http://shaoguangleo.github.io/tags/tr/"/>
    
  </entry>
  
  <entry>
    <title>Linux 终端中漂亮的几款字体</title>
    <link href="http://shaoguangleo.github.io/2023/11/02/linux-beautify-fonts-in-console/"/>
    <id>http://shaoguangleo.github.io/2023/11/02/linux-beautify-fonts-in-console/</id>
    <published>2023-11-02T14:28:00.000Z</published>
    <updated>2025-06-19T13:19:18.868Z</updated>
    
    <content type="html"><![CDATA[<h1 id="linux终端中最漂亮的几款字体"><a href="#linux终端中最漂亮的几款字体" class="headerlink" title="linux终端中最漂亮的几款字体"></a>linux终端中最漂亮的几款字体</h1><p>.. note::<br>  念去去，千里烟波，暮霭沉沉楚天阔。<br>  柳永 《雨霖铃·寒蝉凄切》</p><blockquote><p>仅个人想法，会持续不间断更新和改进。</p></blockquote><p>对于长时间盯着终端来操作的<strong>拥趸</strong>而言，漂亮赏心悦目的字体是不可或缺的。</p><p>但编程字体的选择，看似简单，实则深藏玄机，不同的字体设计初衷各有千秋。</p><p>而编码阅读字体，追求的是流畅的感觉，轻松的识别和愉悦的体验。</p><p>不过，在编程的世界里，字体的功能性有点凌驾于美学之上。</p><p>这也是缘何程序员们偏爱等宽字体的原因，不易出bug。</p><p>所以结合功能性，兼具美术感，就是最佳的字体选择了。</p><p>举个最简单的例子，不易区分的1和I，不同宽度的W和I，给编程带来的体验是不同的。</p><p>这里整理的一些字体尽量能兼具以上的优点，规避一些缺点，助力书写代码新篇章。</p><p>Ubuntu 发行版是最开始用的，可是对终端下的字体一直不是很满意，今天终于找到了一些比较好看的终端字体，尤其是<strong>Droid sans mono</strong>字体，超爱，linux迷在Ubuntu下一直用的就是这款字体，很漂亮，极力推荐下面的几种字体:</p><h2 id="Inconsolata-优雅漂亮的等宽字体"><a href="#Inconsolata-优雅漂亮的等宽字体" class="headerlink" title="Inconsolata 优雅漂亮的等宽字体"></a>Inconsolata 优雅漂亮的等宽字体</h2><p>我最喜欢的等宽字体，免费。线条清晰，很适合长时间的阅读和编写代码。</p><p>偶遇它之后，很快就把原来的默认字体<strong>DejaVu Sans Mono</strong>抛弃了。真正适合任何字号的好字体。感谢它的创造者<strong>Raph Levien</strong>！</p><p><img src="/2023/11/02/linux-beautify-fonts-in-console/../images/programming-fonts-Inconsolata.png" alt="programming-fonts-Inconsolata"></p><h2 id="monaspace-变成利器"><a href="#monaspace-变成利器" class="headerlink" title="monaspace 变成利器"></a>monaspace 变成利器</h2><p>Github出品的Monaspace字体家族，具有能够满足程序员挑剔需求的利器。</p><p><img src="/2023/11/02/linux-beautify-fonts-in-console/../images/programming-fonts-monaspace.png" alt="programming-fonts-monaspace"></p><p>Ubuntu安装命令如下：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">sudo</span> apt-get install fonts-inconsolata</span><br></pre></td></tr></tbody></table></figure><h2 id="Monaco"><a href="#Monaco" class="headerlink" title="Monaco"></a>Monaco</h2><p>Mac的默认字体，好像也只有Mac上有。小字号的时候表现不错，而且再大些也不寒碜。普遍被认为是写代码的专用字体。随后的Menlo字体也是相当的不错。</p><p><img src="/2023/11/02/linux-beautify-fonts-in-console/../images/programming-fonts-Monaco.png" alt="programming-fonts-Monaco"></p><h2 id="Profont"><a href="#Profont" class="headerlink" title="Profont"></a>Profont</h2><p>与Monaco类似的位图字体，你能够在Mac, Windows和Linux上面使用。小字号的时候表现好。非Mac平台上Monaco的最佳替代。喜欢小字号且不怕眼睛疲劳的同学可以考虑。</p><p><img src="/2023/11/02/linux-beautify-fonts-in-console/../images/programming-fonts-ProFont.svg.png" alt="programming-fonts-ProFont"></p><h2 id="Envy-Code-R-具备复古风格"><a href="#Envy-Code-R-具备复古风格" class="headerlink" title="Envy Code R 具备复古风格"></a>Envy Code R 具备复古风格</h2><p>复古的风格，线条流畅，字母衔接自然，代码阅读更流畅。</p><p><img src="/2023/11/02/linux-beautify-fonts-in-console/../images/programming-fonts-envycoder.png" alt="programming-fonts-envycoder"></p><h2 id="Droid-Sans-Mono"><a href="#Droid-Sans-Mono" class="headerlink" title="Droid Sans Mono"></a>Droid Sans Mono</h2><p>开源字体，适合手机屏幕。是等宽字体中最突出的一个。可惜0和O区别不大。</p><p>安装命令：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">sudo</span> apt-get install ttf-droid</span><br></pre></td></tr></tbody></table></figure><p><img src="/2023/11/02/linux-beautify-fonts-in-console/../images/programming-fonts-DroidSansMono.png" alt="programming-fonts-DroidSansMono"></p><h2 id="DejaVu-Sans-Mono-很多Linux发行版的标配"><a href="#DejaVu-Sans-Mono-很多Linux发行版的标配" class="headerlink" title="DejaVu Sans Mono 很多Linux发行版的标配"></a>DejaVu Sans Mono 很多Linux发行版的标配</h2><p>我以前最喜欢的免费字体系列，以<strong>Vera</strong>为基础，但是比后者提供更多字符了。</p><p>适于任何字号，最重要的是无论终端窗口如何变化，始终能保持字体的清晰。</p><p><img src="/2023/11/02/linux-beautify-fonts-in-console/../images/programming-fonts-DejaVu_Sans_Mono.png" alt="programming-fonts-DejaVu_Sans_Mono"></p><p>安装命令如下：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">sudo</span> apt-get install fonts-dejavu-core</span><br></pre></td></tr></tbody></table></figure><h2 id="Terminus-机械感十足"><a href="#Terminus-机械感十足" class="headerlink" title="Terminus 机械感十足"></a>Terminus 机械感十足</h2><p>机械感十足的字体，安装命令如下：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">sudo</span> apt-get install xfonts-terminus</span><br></pre></td></tr></tbody></table></figure><p><img src="/2023/11/02/linux-beautify-fonts-in-console/../images/programming-fonts-Terminus_Specimen.png" alt="programming-fonts-Terminus_Specimen"></p><h2 id="Fira-Code-特别好的编程字体"><a href="#Fira-Code-特别好的编程字体" class="headerlink" title="Fira Code 特别好的编程字体"></a>Fira Code 特别好的编程字体</h2><p>Fira Code也是一款等宽字体，以其独特的编码连字和ASCII支持而闻名。</p><p>这款字体能够提供清晰、易读的文本，非常适合长时间在终端中工作。</p><p><img src="/2023/11/02/linux-beautify-fonts-in-console/../images/programming-fonts--firacode.png" alt="programming-fonts--firacode"></p><p>安装方法如下：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">sudo</span> apt-get install firacode</span><br></pre></td></tr></tbody></table></figure><h2 id="SourceCode-Pro-优雅且剑指源码"><a href="#SourceCode-Pro-优雅且剑指源码" class="headerlink" title="SourceCode Pro 优雅且剑指源码"></a>SourceCode Pro 优雅且剑指源码</h2><p>SourceCode Pro单看这名字就知道剑指源码编辑，不过作为Adobe开发的字体，当然不仅仅为编码环境优化，清晰的线条和易读的字母，无论在何处使用，都能为你提供愉悦的体验。</p><p>更多详细的信息，可以参考官网：<a href="https://adobe-fonts.github.io/source-code-pro/">Source Code Pro (adobe-fonts.github.io)</a> </p><p><img src="/2023/11/02/linux-beautify-fonts-in-console/../images/programming-fonts-Source_Code.png" alt="programming-fonts-Source_Code"></p><h2 id="安装方法"><a href="#安装方法" class="headerlink" title="安装方法"></a>安装方法</h2><p>对于MacOSX而言，其他很多字体都已经打包好了，以monaspace为例，执行下面的两个命令即可安装。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ brew tap homebrew/cask-fonts</span><br><span class="line">$ brew install font-monaspace</span><br></pre></td></tr></tbody></table></figure><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://en.wikipedia.org/wiki/Inconsolata">https://en.wikipedia.org/wiki/Inconsolata</a></li><li></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;linux终端中最漂亮的几款字体&quot;&gt;&lt;a href=&quot;#linux终端中最漂亮的几款字体&quot; class=&quot;headerlink&quot; title=&quot;linux终端中最漂亮的几款字体&quot;&gt;&lt;/a&gt;linux终端中最漂亮的几款字体&lt;/h1&gt;&lt;p&gt;.. note::&lt;br&gt; </summary>
      
    
    
    
    <category term="Linux集锦" scheme="http://shaoguangleo.github.io/categories/Linux%E9%9B%86%E9%94%A6/"/>
    
    
    <category term="linux" scheme="http://shaoguangleo.github.io/tags/linux/"/>
    
    <category term="ubuntu" scheme="http://shaoguangleo.github.io/tags/ubuntu/"/>
    
    <category term="DejaVu" scheme="http://shaoguangleo.github.io/tags/DejaVu/"/>
    
    <category term="droid" scheme="http://shaoguangleo.github.io/tags/droid/"/>
    
    <category term="envy" scheme="http://shaoguangleo.github.io/tags/envy/"/>
    
    <category term="inconsolata" scheme="http://shaoguangleo.github.io/tags/inconsolata/"/>
    
    <category term="monaco" scheme="http://shaoguangleo.github.io/tags/monaco/"/>
    
    <category term="Profont" scheme="http://shaoguangleo.github.io/tags/Profont/"/>
    
  </entry>
  
  <entry>
    <title>linux中最常用的文件管理命令</title>
    <link href="http://shaoguangleo.github.io/2023/10/17/linux-collection-file-management/"/>
    <id>http://shaoguangleo.github.io/2023/10/17/linux-collection-file-management/</id>
    <published>2023-10-17T14:28:00.000Z</published>
    <updated>2025-06-19T13:19:18.871Z</updated>
    
    <content type="html"><![CDATA[<h1 id="linux中最常用的文件管理命令"><a href="#linux中最常用的文件管理命令" class="headerlink" title="linux中最常用的文件管理命令"></a>linux中最常用的文件管理命令</h1><blockquote><p> 仅个人想法，会持续不间断更新和改进。</p></blockquote><p>在 Linux 系统中，文件管理是基础且重要。</p><p>如何显示，如何查找，如何编辑，如何删除，如何复制，如何移动，如何重命名，如何创建，如何修改，如何查看文件的属性等等，都是我们在日常工作中经常会用到的命令。</p><p>Linux的文件管理命令也会帮助你更高效地在终端中操作文件和目录。</p><p>而其中最绕不开的当属以下几个。</p><ul><li><a href="http://shaoguangleo.github.io/2017/06/08/linux-awk-beginner"> 已经不能用强大描述的 awk</a></li><li><a href="http://shaoguangleo.github.io/2011/02/12/linux-cat-beginner"> 查看庐山真面貌的cat</a></li><li><a href="http://shaoguangleo.github.io/2011/02/12/linux-cp-beginner"> 安全起见，拷贝为先 - cp</a></li><li><a href="http://shaoguangleo.github.io/2019/04/07/linux-cut-beginner"> cut todo</a></li><li><a href="http://shaoguangleo.github.io/2013/03/06/linux-diff-beginner"> 远看高低各不同 diff</a></li><li><a href="http://shaoguangleo.github.io/2012/02/12/linux-head-beginner"> 从头开始的head</a></li><li><a href="http://shaoguangleo.github.io/2012/07/07/linux-ls-beginner"> 最常用的且没有之一的  ls</a></li><li><a href="http://shaoguangleo.github.io/2011/02/12/linux-mkdir-beginner"> Linux的 mkdir 命令</a></li><li><a href="http://shaoguangleo.github.io/2011/02/12/linux-mv-beginner"> Linux的 mv 命令</a></li><li><a href="http://shaoguangleo.github.io/2022/07/07/linux-sed-beginner"> sed 入门</a></li><li><a href="http://shaoguangleo.github.io/2011/02/12/linux-tac-beginner"> 反向显示之 tac</a></li><li><a href="http://shaoguangleo.github.io/2011/02/12/linux-tail-beginner"> 不可狗尾续貂的tail</a></li><li><a href="http://shaoguangleo.github.io/2012/12/27/linux-uniq-beginner"> 你是唯一的 uniq</a></li></ul><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>更多信息请阅读原文。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;linux中最常用的文件管理命令&quot;&gt;&lt;a href=&quot;#linux中最常用的文件管理命令&quot; class=&quot;headerlink&quot; title=&quot;linux中最常用的文件管理命令&quot;&gt;&lt;/a&gt;linux中最常用的文件管理命令&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt; </summary>
      
    
    
    
    <category term="Linux集锦" scheme="http://shaoguangleo.github.io/categories/Linux%E9%9B%86%E9%94%A6/"/>
    
    
    <category term="echo" scheme="http://shaoguangleo.github.io/tags/echo/"/>
    
    <category term="cat" scheme="http://shaoguangleo.github.io/tags/cat/"/>
    
    <category term="文件管理" scheme="http://shaoguangleo.github.io/tags/%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/"/>
    
    <category term="pwd" scheme="http://shaoguangleo.github.io/tags/pwd/"/>
    
    <category term="chgrp" scheme="http://shaoguangleo.github.io/tags/chgrp/"/>
    
    <category term="chmod" scheme="http://shaoguangleo.github.io/tags/chmod/"/>
    
    <category term="chown" scheme="http://shaoguangleo.github.io/tags/chown/"/>
    
    <category term="ls" scheme="http://shaoguangleo.github.io/tags/ls/"/>
    
    <category term="tac" scheme="http://shaoguangleo.github.io/tags/tac/"/>
    
    <category term="file" scheme="http://shaoguangleo.github.io/tags/file/"/>
    
    <category term="less" scheme="http://shaoguangleo.github.io/tags/less/"/>
    
    <category term="more" scheme="http://shaoguangleo.github.io/tags/more/"/>
    
    <category term="tail" scheme="http://shaoguangleo.github.io/tags/tail/"/>
    
    <category term="ln" scheme="http://shaoguangleo.github.io/tags/ln/"/>
    
    <category term="tee" scheme="http://shaoguangleo.github.io/tags/tee/"/>
    
  </entry>
  
  <entry>
    <title>Linux 集锦 之 最常用的几个命令</title>
    <link href="http://shaoguangleo.github.io/2023/10/11/linux-collection-most-used-commands/"/>
    <id>http://shaoguangleo.github.io/2023/10/11/linux-collection-most-used-commands/</id>
    <published>2023-10-11T14:11:00.000Z</published>
    <updated>2025-06-19T13:19:18.872Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux最常用的几个命令"><a href="#Linux最常用的几个命令" class="headerlink" title="Linux最常用的几个命令"></a>Linux最常用的几个命令</h1><p>​Linux系统中的命令那是相当地丰富，不同的版本可能还有不同的命令，不过Linux核心自带的命令大概有几百个，这个不管是什么发行版一般都是共用的。</p><p>​如果希望探索Linux的所有命令，可能不太实际，因为这个数字可能达到惊人的万计。</p><p>​不过还好的是，Linux命令的入门只要掌握不到100个命令即可，而如果相对而言行云流水的话也就200个命令足矣。</p><p>​而如果准备试试Linux，可能只需要下面的几个实用频率最高、功能最关键、也最常用的命令也就基本可以完成日常的工作、学习需要了。</p><p>​忽然想用姓氏排序的方法，不过感觉不太行，索性就大概按照使用率来统计了。</p><p>​仅个人习惯，会持续不间断更新和改进。</p><hr><h2 id="ls-列出当前目录下的文件📃和文件夹📁列表"><a href="#ls-列出当前目录下的文件📃和文件夹📁列表" class="headerlink" title="ls 列出当前目录下的文件📃和文件夹📁列表"></a>ls 列出当前目录下的文件📃和文件夹📁列表</h2><p>​个人感觉这个命令，属于名副其实用的最多的命令，我们进入Linux的第一个命令，可能除了输入用户名密码就属它了。</p><p>​工欲善其事，必先利其器，你欲使用Linux，必先了解当前的文件和内容。</p><h3 id="不加任何参数"><a href="#不加任何参数" class="headerlink" title="不加任何参数"></a>不加任何参数</h3><p>如果不加任何参数，默认列出当前目录的内容。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">ls</span> /etc/sysconfig/network-scripts</span><br><span class="line">ifcfg-em1</span><br><span class="line">ifcfg-em2</span><br><span class="line">ifcfg-em3</span><br><span class="line">ifcfg-em4   </span><br><span class="line">....</span><br></pre></td></tr></tbody></table></figure><h3 id="使用-l显示更多细节"><a href="#使用-l显示更多细节" class="headerlink" title="使用-l显示更多细节"></a>使用-l显示更多细节</h3><p>-l 就是使用long listing format长格式，来显示更多的内容信息。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">ls</span> -l /etc/sysconfig/network-scripts</span><br><span class="line">total 264</span><br><span class="line">-rw-r--r--. 1 root root   341 Nov 30 10:56 ifcfg-em1</span><br><span class="line">-rw-r--r--. 1 root root   294 May 13  2016 ifcfg-em2</span><br><span class="line">-rw-r--r--. 1 root root   272 May 10  2016 ifcfg-em3</span><br><span class="line">-rw-r--r--. 1 root root   272 May 10  2016 ifcfg-em4</span><br><span class="line">......</span><br></pre></td></tr></tbody></table></figure><h3 id="使用-t按照时间排序"><a href="#使用-t按照时间排序" class="headerlink" title="使用-t按照时间排序"></a>使用-t按照时间排序</h3><p>如果希望看到最近创建的文件，就需要用到-t参数了。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">ls</span> -lt /etc/sysconfig/network-scripts/</span><br><span class="line">total 264</span><br><span class="line">-rw-r--r--. 1 root root   341 Nov 30 10:56 ifcfg-em1</span><br><span class="line">-rw-r--r--. 1 root root   294 May 13  2016 ifcfg-em2</span><br><span class="line">-rw-r--r--. 1 root root   272 May 10  2016 ifcfg-em4</span><br><span class="line">-rw-r--r--. 1 root root   272 May 10  2016 ifcfg-em3</span><br><span class="line">...</span><br></pre></td></tr></tbody></table></figure><h3 id="使用-r按照时间逆序"><a href="#使用-r按照时间逆序" class="headerlink" title="使用-r按照时间逆序"></a>使用-r按照时间逆序</h3><p>如果希望删除很早以前的文件，看到最早创建的文件，就需要用到-r参数了。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">ls</span> -ltr /etc/sysconfig/network-scripts/</span><br><span class="line">total 264</span><br><span class="line">...</span><br><span class="line">-rw-r--r--. 1 root root   272 May 10  2016 ifcfg-em3</span><br><span class="line">-rw-r--r--. 1 root root   272 May 10  2016 ifcfg-em4</span><br><span class="line">-rw-r--r--. 1 root root   294 May 13  2016 ifcfg-em2</span><br><span class="line">-rw-r--r--. 1 root root   341 Nov 30 10:56 ifcfg-em1</span><br></pre></td></tr></tbody></table></figure><h3 id="使用-S根据文件大小排序"><a href="#使用-S根据文件大小排序" class="headerlink" title="使用-S根据文件大小排序"></a>使用-S根据文件大小排序</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">ls</span> -lS /etc/sysconfig/network-scripts/</span><br><span class="line">total 264</span><br><span class="line">...</span><br><span class="line">-rw-r--r--. 1 root root   341 Nov 30 10:56 ifcfg-em1</span><br><span class="line">-rw-r--r--. 1 root root   294 May 13  2016 ifcfg-em2</span><br><span class="line">-rw-r--r--. 1 root root   272 May 10  2016 ifcfg-em3</span><br><span class="line">-rw-r--r--. 1 root root   272 May 10  2016 ifcfg-em4</span><br></pre></td></tr></tbody></table></figure><h2 id="cd-改变当前的工作目录"><a href="#cd-改变当前的工作目录" class="headerlink" title="cd 改变当前的工作目录"></a>cd 改变当前的工作目录</h2><p>这个命令可能估计能排在第二，类似于Winows的双击，在不同目录件徜徉。</p><p>在各个文件夹遍历是我们的习惯和倔强的证明。</p><p>cd命令没有太多参数，但是有一些技巧所在，可以N多人从来没有用过。</p><p>cd直接使用即可，技巧是下面几个：</p><h3 id="进入刚才的目录"><a href="#进入刚才的目录" class="headerlink" title="进入刚才的目录"></a>进入刚才的目录</h3><p>想要进入刚才进入的地方（目测没有很多人再用，但是真的很好用）运行：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> –</span><br></pre></td></tr></tbody></table></figure><h3 id="快速返回家目录"><a href="#快速返回家目录" class="headerlink" title="快速返回家目录"></a>快速返回家目录</h3><p>需要快速地回到你的家目录，输入<code>cd</code>即可，这里其实不用一级一级的进入</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span></span><br></pre></td></tr></tbody></table></figure><h3 id="进入某用户的家目录"><a href="#进入某用户的家目录" class="headerlink" title="进入某用户的家目录"></a>进入某用户的家目录</h3><p>这个需要你有root权限</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~username</span><br></pre></td></tr></tbody></table></figure><p>进入username的家目录。</p><h2 id="mkdir-创建目录"><a href="#mkdir-创建目录" class="headerlink" title="mkdir - 创建目录"></a>mkdir - 创建目录</h2><p>说到cd到某个目录，就需要提高创建目录，也就新建文件夹。</p><p>参数不过，处理默认什么参数也不加，会一个-p递归创建文件夹即可。</p><h3 id="创建一个空目录"><a href="#创建一个空目录" class="headerlink" title="创建一个空目录"></a>创建一个空目录</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">mkdir</span> hello</span><br></pre></td></tr></tbody></table></figure><h3 id="递归创建多个目录"><a href="#递归创建多个目录" class="headerlink" title="递归创建多个目录"></a>递归创建多个目录</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">mkdir</span> -p a/b/c/d/e/f/g</span><br></pre></td></tr></tbody></table></figure><h2 id="rm-删除文件"><a href="#rm-删除文件" class="headerlink" title="rm - 删除文件"></a>rm - 删除文件</h2><p><code>rm</code> 命令用于删除文件或者目录。</p><p>这个命令其实我不想把它归为最常用的命令，因为它也是最危险⚠️的命令之一，文件一旦通过rm命令删除❌，则无法恢复，所以必须格外一定切记小心地使用该命令。因为发生过很多欲哭无泪的故事。。。</p><p>文件如果少，可以使用<code>-i</code> 删除前逐一询问确认，确认时比较好用；</p><p>而下面的两个参数十分残暴，除非百分之两百确认，否则慎用：</p><ul><li><code>-f</code> 即使原档案属性设为唯读，也直接删除，无需逐一确认，是<strong>force</strong>的意思。</li><li><code>-r</code> 将目录及里面的子文件逐一删除。</li></ul><h2 id="cp-复制文件"><a href="#cp-复制文件" class="headerlink" title="cp - 复制文件"></a>cp - 复制文件</h2><p>cp可以实现文件和目录的复制，如果你只会<code>cp a b</code>，或者加上-r来递归目录，那么你还需要挖掘很多呀，比如只复制不存在或者更新的文件。</p><p>以下就是<code>cp</code>常用的选项如下所示：</p><ul><li><code>i</code> : 覆盖一个已经存在的文件前，提示用户进行确认</li><li><code>r</code>：递归地复制目录及其内容，复制目录的时候必须使用这个参数</li><li><code>u</code>：只复制不存在或者更新的文件</li><li><code>v</code>：复制文件时，显示复制信息</li></ul><h3 id="组合rv-可以拷贝文件或文件夹"><a href="#组合rv-可以拷贝文件或文件夹" class="headerlink" title="组合rv - 可以拷贝文件或文件夹"></a>组合rv - 可以拷贝文件或文件夹</h3><p>这个在显示复制信息的时候，也可以复制目录</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cp</span> -rv dir1/* dir2/</span><br><span class="line">‘dir1/a’ -&gt; ‘dir2/a’</span><br><span class="line">‘dir1/b’ -&gt; ‘dir2/b’</span><br><span class="line">‘dir1/c’ -&gt; ‘dir2/c’</span><br><span class="line">‘dir1/d’ -&gt; ‘dir2/d’</span><br></pre></td></tr></tbody></table></figure><h3 id="拷贝时提示确认"><a href="#拷贝时提示确认" class="headerlink" title="拷贝时提示确认"></a>拷贝时提示确认</h3><p>这个参数在使用rm的时候已经记得使用，不然就像<code>rm -rf /</code>一样，一个公司没有了。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cp</span> -i dir1/* dir2/</span><br><span class="line"><span class="built_in">cp</span>: overwrite ‘dir2/a’? y</span><br><span class="line"><span class="built_in">cp</span>: overwrite ‘dir2/b’? y</span><br><span class="line"><span class="built_in">cp</span>: overwrite ‘dir2/c’? y</span><br></pre></td></tr></tbody></table></figure><blockquote><p>这个选项在文件超级多时候，慎用！！</p></blockquote><h3 id="只拷贝不存在或更新的文件"><a href="#只拷贝不存在或更新的文件" class="headerlink" title="只拷贝不存在或更新的文件"></a>只拷贝不存在或更新的文件</h3><p><code>u</code>表示<code>update</code>，也就是从一个目录拷贝到另外一个目录时，只会复制那些不存在或者目标目录相应文件的更新文件。</p><p>执行下面的命令：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cp</span> -u dir1/* dir2/</span><br></pre></td></tr></tbody></table></figure><p>可以得到：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ ll *</span><br><span class="line">dir1:</span><br><span class="line">total 0</span><br><span class="line">-rw-rw-r-- 1 user user 0 Jul 20 21:23 a</span><br><span class="line">-rw-rw-r-- 1 user user 0 Jul 20 21:23 b</span><br><span class="line">-rw-rw-r-- 1 user user 0 Jul 20 21:23 c</span><br><span class="line">-rw-rw-r-- 1 user user 0 Jul 20 21:23 d</span><br><span class="line"></span><br><span class="line">dir2:</span><br><span class="line">total 0</span><br><span class="line">-rw-rw-r-- 1 user user 0 Jul 20 21:29 a</span><br><span class="line">-rw-rw-r-- 1 user user 0 Jul 20 21:25 b</span><br><span class="line">-rw-rw-r-- 1 user user 0 Jul 20 21:29 c</span><br><span class="line">-rw-rw-r-- 1 user user 0 Jul 20 21:25 d</span><br><span class="line">-rw-rw-r-- 1 user user 0 Jul 20 21:25 e</span><br></pre></td></tr></tbody></table></figure><h3 id="如何用cp拷贝指定序号的文件"><a href="#如何用cp拷贝指定序号的文件" class="headerlink" title="如何用cp拷贝指定序号的文件"></a>如何用cp拷贝指定序号的文件</h3><p>现在有文件夹<code>filename</code>，内有文档，名字是从<code>1.txt, 2.txt, 3.txt</code> 一直到<code>9999.txt,10000.txt</code>,现在希望从第<code>N</code>组数据即<code>N.txt</code>到第<code>M</code>组数据<code>M.txt</code>的文件拷贝到别的文件夹中，方法如下：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cp</span> {N..M}.txt   newfilename/</span><br></pre></td></tr></tbody></table></figure><p>这个方法可是相当的赞呀<del>(≧▽≦)/</del>，基本可以秒掉大多数的GUI程序了。</p><h2 id="mv-文件移动或者叫重命名"><a href="#mv-文件移动或者叫重命名" class="headerlink" title="mv - 文件移动或者叫重命名"></a>mv - 文件移动或者叫重命名</h2><p>如果mv的命令还停留在重命名一个文件或者文件夹，那么就花3分钟看一下。</p><p>mv能做的还很多。</p><p>比如为了防止误删，mv可以提前做个备份；比如为了防止覆盖，可以考虑只有文件较新的时候才移动。</p><p>详细如下：</p><p>mv几个比较常用的选项如下：</p><ul><li><strong>-b</strong>: 当目标文件或目录存在时，在执行覆盖前，会为其创建一个备份，文件后缀用~表示；</li><li><strong>-i</strong>或–interactive: 如果指定移动的源目录或文件与目标的目录或文件同名，则会先询问是否覆盖旧文件，输入 y 表示直接覆盖，输入 n 表示取消该操作，一般而言，对于不确定的时候可以用此选项，不过文件或文件夹居多时，最好不要用</li><li><strong>-f</strong>或–force: 如果指定移动的源目录或文件与目标的目录或文件同名，不会询问，直接覆盖旧文件，强制的意思force</li><li><strong>-n</strong>或–no-clobber: 不要覆盖任何已存在的文件或目录。</li><li><strong>-u</strong>：当源文件比目标文件新或者目标文件不存在时，才执行移动操作。</li></ul><h3 id="常规操作"><a href="#常规操作" class="headerlink" title="常规操作"></a>常规操作</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">ls</span></span><br><span class="line">a.txt</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">mv</span> a.txt b.txt</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">ls</span></span><br><span class="line">b.txt</span><br></pre></td></tr></tbody></table></figure><p>直接移动或者叫做重命名，文件夹也类似的操作。</p><h3 id="覆盖前备份"><a href="#覆盖前备份" class="headerlink" title="覆盖前备份"></a>覆盖前备份</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">ls</span></span><br><span class="line">a.txt  a.txt~</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">cp</span> -b ../a.txt a.txt</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">ls</span></span><br><span class="line">a.txt  a.txt~</span><br></pre></td></tr></tbody></table></figure><blockquote><p>可以看到此时多了一个备份文件</p></blockquote><h3 id="增量更新"><a href="#增量更新" class="headerlink" title="增量更新"></a>增量更新</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cp</span> -u a b</span><br></pre></td></tr></tbody></table></figure><blockquote><p>此时的操作为，只有a比b更新或者b不存在的时候，才会进行更新，否则失败。</p><p>这个用法多用在：当横向对比两个文价夹有无重要更新的时候才会用到。</p></blockquote><h3 id="交互提示"><a href="#交互提示" class="headerlink" title="交互提示"></a>交互提示</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cp</span> -i b.txt a.txt</span><br><span class="line"><span class="built_in">cp</span>：是否覆盖<span class="string">"a.txt"</span>？ </span><br></pre></td></tr></tbody></table></figure><blockquote><p>在文件存在的时候，-i选项会进行提示，此时需要输入y才能覆盖，而输入n就会取消这个操作。</p></blockquote><h2 id="pwd-查看目录所在的命令"><a href="#pwd-查看目录所在的命令" class="headerlink" title="pwd - 查看目录所在的命令"></a>pwd - 查看目录所在的命令</h2><p><code>pwd</code>命令的作用是查看当前目录，没有参数，输入后回车即可显示当前绝对路径， 所以<code>pwd</code>是<strong>P</strong>rint <strong>W</strong>orking  <strong>D</strong>irectory第一个字的缩写。</p><p>唯二需要了解的参数如下：</p><ul><li><code>-L</code>, <code>--logical</code>：打印逻辑路径，与<code>pwd</code>一致</li><li><code>-P</code>, <code>--physical</code>：打印物理路径，这里可以从超级链接直达原处</li></ul><h3 id="实例展示"><a href="#实例展示" class="headerlink" title="实例展示"></a>实例展示</h3><p>此时比如我们进入一个目录，然后在打印出来，如下：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> /etc/sysconfig/network-scripts/</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">pwd</span></span><br><span class="line">/etc/sysconfig/network-scripts</span><br></pre></td></tr></tbody></table></figure><blockquote><p>可以看到pwd将输出完全路径</p></blockquote><h3 id="逻辑与物理路径"><a href="#逻辑与物理路径" class="headerlink" title="逻辑与物理路径"></a>逻辑与物理路径</h3><p>比如如下：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">pwd</span></span><br><span class="line">/opt/test</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">ls</span> -l</span><br><span class="line">总用量 1</span><br><span class="line">lrwxrwxrwx  1 root root   14 Jan 15 2012 <span class="built_in">dir</span> -&gt; <span class="built_in">source</span>/dir</span><br><span class="line">drwxrwxrwx  1 root root   14 Jan 15 2012 <span class="built_in">source</span></span><br></pre></td></tr></tbody></table></figure><p>可以看到此时的路径在<u>/opt/test/</u>里面有两个目录<u>source</u>和<u>dir</u>，其中<u>dir</u>链接到<u>source</u>里面的dir。</p><p>接下来对比一下-L和-P的区别。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> <span class="built_in">dir</span></span><br><span class="line"></span><br><span class="line">$ <span class="built_in">pwd</span></span><br><span class="line">/opt/test/dir</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">pwd</span> -L</span><br><span class="line">/opt/test/dir</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">pwd</span> -P</span><br><span class="line">/opt/test/source/dir</span><br></pre></td></tr></tbody></table></figure><p>从上面的输出可以发现，<code>-P</code>参数会显示文件最原始的路径；而<code>-L</code>则是逻辑上的路径。</p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Linux最常用的几个命令&quot;&gt;&lt;a href=&quot;#Linux最常用的几个命令&quot; class=&quot;headerlink&quot; title=&quot;Linux最常用的几个命令&quot;&gt;&lt;/a&gt;Linux最常用的几个命令&lt;/h1&gt;&lt;p&gt;​	Linux系统中的命令那是相当地丰富，不同的版本</summary>
      
    
    
    
    <category term="Linux集锦" scheme="http://shaoguangleo.github.io/categories/Linux%E9%9B%86%E9%94%A6/"/>
    
    
    <category term="Linux" scheme="http://shaoguangleo.github.io/tags/Linux/"/>
    
    <category term="cd" scheme="http://shaoguangleo.github.io/tags/cd/"/>
    
    <category term="Linux汇总" scheme="http://shaoguangleo.github.io/tags/Linux%E6%B1%87%E6%80%BB/"/>
    
    <category term="ls" scheme="http://shaoguangleo.github.io/tags/ls/"/>
    
    <category term="常用命令" scheme="http://shaoguangleo.github.io/tags/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    
    <category term="mkdir" scheme="http://shaoguangleo.github.io/tags/mkdir/"/>
    
    <category term="cp" scheme="http://shaoguangleo.github.io/tags/cp/"/>
    
    <category term="mv" scheme="http://shaoguangleo.github.io/tags/mv/"/>
    
    <category term="Linux集锦" scheme="http://shaoguangleo.github.io/tags/Linux%E9%9B%86%E9%94%A6/"/>
    
  </entry>
  
</feed>
